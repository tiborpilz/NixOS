#+PROPERTY: header-args :elisp :tangle ./config.el :results silent
#+TITLE: Doom Emacs Config

* Base Settings
** Personal data
Set Name and mail adress
#+begin_src elisp
(setq user-full-name "Tibor Pilz"
      user-mail-address "tibor@pilz.berlin")
#+end_src

** Add checks for different machines
Although I would like to keep the differences between my development
environments as low as possible - also to counteract configuration drift, there
are some settings that need to be specific to some of my machines - e.g. the
font-size. So, I define some basic functions to check which machine is curently
running this config, and adjust certain settings accordingly.

#+begin_src elisp
(defun is-mac ()
  (string-equal system-type "darwin"))

(defun is-linux ()
  (string-equal system-type "gnu/linux"))

(defun is-workstation ()
  (string-equal (system-name) "workyMcWorkstation"))
#+end_src

** Font selection
I'm a big fan of ligatures, and I've been using FiraCode for as long as I can remember.

#+begin_src elisp
(setq doom-font (font-spec :family "FiraCode Nerd Font" :size 14))
#+end_src

** Line numbers
Since I'm using Evil/vim-keybindings, I prefer relative line numbers as default.

#+begin_src elisp
(setq display-line-numbers-type 'relative)
#+end_src

** Tab width
2 spaces, suck it k&r
#+begin_src elisp
(setq tab-width 2)
#+end_src

** Fix straight.el
https://github.com/doomemacs/doomemacs/issues/6960#issuecomment-1327514660

#+begin_src elisp :tangle packages.el
(package! straight :pin "3eca39d")
#+end_src

** Editorconfig
#+begin_src elisp :tangle packages.el
(package! editorconfig)
#+end_src

** Fix PATH in macos
When using gui emacs in macos, env vars like PATH are not set correctly.
~exec-path-from-shell~ fixes that.

#+begin_src elisp :tangle packages.el
(package! exec-path-from-shell)
#+end_src

Only initialize when running in a GUI frame on macos and linux.
#+begin_src elisp
(use-package! exec-path-from-shell
  :ensure t
  :if (memq window-system '(mac ns x))
  :config
  (setq exec-path-from-shell-variables '("PATH" "NVM_DIR" "NVM_BIN"))
  (exec-path-from-shell-initialize))
#+end_src
* Org Mode
** Base Settings
#+begin_src elisp
(setq org-directory "~/org/")
(setq org-agenda-files (list org-directory))

(setq org-use-property-inheritance t)
(setq org-log-done 'time) ; Log time when task completes
(setq org-list-allow-alphabetical t)       ; a, A, a) A) list bullets)
(setq org-catch-invisible-edits 'smart) ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{})

(setq org-return-follows-link 1)
(setq calendar-week-start-day 1) ;; start on monday
(setq org-agenda-include-diary t)
#+end_src

** Visual improvements
*** Set headline typography
#+begin_src elisp :tangle none
(let* ((variable-tuple '(:font "FiraCode Nerd Font"))
       (headline `(:inherit default :weight heavy)))
  (custom-theme-set-faces
   'user
   `(org-level-8 ((t (,@headline ,@variable-tuple))))
   `(org-level-7 ((t (,@headline ,@variable-tuple))))
   `(org-level-6 ((t (,@headline ,@variable-tuple))))
   `(org-level-5 ((t (,@headline ,@variable-tuple))))
   `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
   `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.17))))
   `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.23))))
   `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.3))))
   `(org-document-title ((t (,@headline ,@variable-tuple :height 1.4 :underline nil))))))
#+end_src

*** Hide leading stars except for currently selected headline
#+begin_src elisp
(setq org-hide-leading-stars t)
#+end_src

*** Don't indent content based on headline level
#+begin_src elisp
(setq org-startup-indented t)
#+end_src
*** Make Org-Modern look good
**** TODO actually implement this :emacs:
Currently, this has some issues with doom emacs.

Org-modern (https://github.com/minad/org-modern) contains a lot of nice visual
improvements for org-mode.

(I Need to adjust the style to fit into my theme)

#+begin_src elisp :tangle none
;; (package! org-modern)
#+end_src


Use it globally and tweak it some more.
#+begin_src elisp :tangle none
;; (modify-all-frames-parameters
;;  '((right-divider-width . 10)
;;    (internal-border-width . 10)))
;; (dolist (face '(window-divider
;;                 window-divider-first-pixel
;;                 window-divider-last-pixel))
;;   (face-spec-reset-face face)
;;   (set-face-foreground face (face-attribute 'default :background)))
;; (set-face-background 'fringe (face-attribute 'default :background))

;; (use-package! org-modern
;;   :after org
;;   :custom
;;   (org-modern-star '("◉" "○" "◈" "◇" "•"))
;;   (org-modern-timestamp '(" %d.%m.%Y " . " %H:%M ")))

;; (setq
;;  ;; Edit settings
;;  org-auto-align-tags nil
;;  org-tags-column 0
;;  org-catch-invisible-edits 'show-and-error
;;  org-special-ctrl-a/e t
;;  org-insert-heading-respect-content t

;;  ;; Org styling, hide markup etc.
;;  org-hide-emphasis-markers t
;;  org-pretty-entities t
;;  org-ellipsis "…"

;;  ;; Agenda styling
;;  org-agenda-tags-column 0
;;  org-agenda-block-separator ?─
;;  org-agenda-time-grid
;;  '((daily today require-timed)
;;    (800 1000 1200 1400 1600 1800 2000)
;;    " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
;;  org-agenda-current-time-string
;;  "⭠ now ─────────────────────────────────────────────────")

;; (global-org-modern-mode)
#+end_src

*** Vastly improve the tree's display
#+begin_src elisp
(setq neo-theme (if (display-graphic-p) 'icons 'arrow))
#+end_src

*** Show passed deadlines as error
#+begin_src elisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

*** Show quote blocks in italic
#+begin_src elisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

*** Defer font-lock
For a more responsive editing experience
#+begin_src elisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))
#+end_src

** Babel
*** HTTP requests via babel
#+begin_src elisp
(use-package! ob-http
  :commands org-babel-execute:http)
#+end_src

*** Babel header args
See https://org-babel.readthedocs.io/en/latest/header-args/

#+begin_src elisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noeweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src
*** Auto-Tangling TODO: make this work
I want org to tangle my config.org on file save, regardless whether it's the one
loaded or in a different repo.

#+begin_src elisp
(defun org-babel-tangle-config ()
  (when (string-equal (file-name-nondirectory (buffer-file-name))
                      "config.org")
    (let ((org-config-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'after-save-hook #'org-babel-tangle-config)))
#+end_src

** Import/Export
*** View exported file
#+begin_src elisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")

#+end_src

*** use github markdown
#+begin_src elisp
(use-package! ox-gfm :after ox :defer t)
#+end_src

*** Export headings up to five levels deep
#+begin_src elisp
(setq org-export-headline-levels 5)
#+end_src

*** Ignore tag
Add `:ignore:` tag to headings, so only the headings will be ignored for an export
#+begin_src elisp
;(require 'ox-extra)
;(ox-extras-activate '(ignore-headlines))
#+end_src

*** automatic latex rendering
#+begin_code elisp :tangle packages.el
(package! org-fragtog)
#+end_code

#+begin_src elisp :tangle none
(use-package! org-fragtog
  :hook (org-mode . 'org-fragtog-mode))
#+end_src

*** Latex fragments
#+begin_src elisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

*** Presentation
**** Export to Reveal.js
#+begin_src elisp none
;; (use-package! org-re-reveal)
#+end_src
** Extensions
*** Roam
**** Use the same directory as org
#+begin_src elisp
(setq org-roam-directory "~/org/roam")
#+end_src

**** Add Org-Roam UI
Org-Roam UI is a web-based interface for Org-roam. It is a separate package -
and it also needs the websocket package as dependency.

The closest comparison to org-roam-ui is Obsidian.

#+begin_src elisp :tangle packages.el
(unpin! org-roam)
(package! org-roam-ui)
(package! websocket) ; dependency of `org-roam-ui'
#+end_src

#+begin_src elisp
(use-package! websocket
  :after org-roam
  :defer t)

(use-package! org-roam-ui
  :after org-roam
  :config
  (setq org-roam-ui-synch-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))

;; (use-package! org-roam-ui
;;   :after org-roam
;;   :commands org-roam-ui-open
;;   :hook (org-roam . 'org-roam-ui-mode)
;;   :config
;;   (require 'org-roam) ; in case autoloaded
;;   (defun org-roam-ui-open ()
;;     "Ensure the server is active, then open the roam graph."
;;     (interactive    )
;;     (unless org-roam-ui-mode (org-roam-ui-mode 1))
;;     (browse-url-xdg-open (format "http://localhost:%d" org-roam-ui-port))))

;; (setq org-roam-ui-open-on-start nil)
#+end_src

*** Google Calendar integration
#+begin_src elisp :tangle packages.el
(package! org-gcal)
#+end_src

#+begin_src elisp
;; (use-package! org-gcal
;;   :config
;;   (setq org-gcal-client-id "CLIENT_ID"
;;         org-gcal-client-secret "CLIENT_SECRET"
;;         org-gcal-fetch-file-alit '(("tbrpilz@googlemail.com" . "~/org/schedule.org"))))
#+end_src

*** Presentation
**** Org-Present
Org-Present is a package to present org files right out of emacs.
#+begin_src elisp :tangle packages.el
(package! org-present)
#+end_src

#+begin_src elisp
(use-package! org-present
  :hook (org-present-mode . (lambda ()
                              (org-present-big)
                              (org-display-inline-images)
                              (org-present-hide-cursor)
                              (org-present-read-only)))
  :hook (org-present-mode-quit . (lambda ()
                                   (org-present-small)
                                   (org-remove-inline-images)
                                   (org-present-show-cursor)
                                   (org-present-read-write))))
#+end_src
** Fixes and miscellanious improvements
*** Add shortcut for inserting  source, quote and example blocks

For some reqson, ~<S <TAB>~ has stopped working, but I stumbled across
~org-insert-structure-template~ which has the added benefit of choice.

Right now it's stuck on a simple emacs-y keybinding, so I'm changing it to a
more Evil-like one.

It seems that ~localleader~ is pretty swamped, especially in org-mode, so I guess
I waill try to cluster a few keybindings I want to add for aome time now - since
it's Babel related, ~<SPC> [localleader] B~ should fit as an entrypoint.

I'm adjusting the bindings just for ~org-mode~.

#+begin_src elisp
(map! :map org-mode-map
      :localleader
      (:prefix-map ("B" . "babel")
       (:desc "Insert structure template" "c" #'org-insert-structure-template)))
#+end_src


*** Visual-line-mode messes with with plaintext (markdow, latex)
#+begin_src elisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

*** Prevent org-block face for latex fragments, since they look weird
#+begin_src elisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

*** Function to create an org buffer
#+begin_src elisp
(evil-define-command evil-buffer-org-new (count file)
  "creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "new empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src

*** Insert cdlatex enviornments and edit immediately
#+begin_src elisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)

(defadvice! org-edit-latex-env-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

*** Disable auto-fill-mode
Auto-fill-mode automatically adds line breaks while typing in markdown and org files.
Since those files are going to be exported to pdf or html, which take care of proper formatting, I'm disabling this.

For Markdown, add a hook setting auto-fill-mode to -1.
#+begin_src elisp
(add-hook! markdown-mode (auto-fill-mode -1))
#+end_src

*** Nix-Doom-Emacs messes with dashboard
I'm using the nix-doom-emacs package to install emacs & dependencies, and for
some reason, using that binary, the Dashboard is disabled. [[https://github.com/nix-community/nix-doom-emacs/issues/88#issuecomment-1115500602][This comment]] in a
corresponding GH issue has a fix.

#+begin_src elisp
(add-hook! 'emacs-startup-hook #'doom-init-ui-h)
#+end_src
*** Faster insertion of org structures (i.e. source blocks)
For some reason, ~org-tempo~ does not start at launch, so I'm  loading it here.
#+begin_src elisp
(use-package! org-tempo)
#+end_src
** Capture
*** Add / change cappture templates
Some other tools (like orgzly) work better with ~TODO~ instead of ~[ ]~ (and
~DONE~ instead of ~[X]~).

#+begin_src elisp
(after! org
  (setq org-capture-templates
        '(("t" "Personal todo" entry (file+headline +org-capture-todo-file "Inbox")
          "* TODO %?\n%i\n%a" :prepend t)
         ("n" "Personal notes" entry (file+headline +org-capture-notes-file "Inbox")
          "* %u %?\n%i\n%a" :prepend t)
         ("j" "Journal" entry (file+olp+datetree +org-capture-journal-file)
          "* %U %?\n%i\n%a" :prepend t)
         ("p" "Templates for projects")
         ("pt" "Project-local todo" entry
          (file+headline +org-capture-project-todo-file "Inbox") "* TODO %?\n%i\n%a"
          :prepend t)
         ("pn" "Project-local notes" entry
          (file+headline +org-capture-project-notes-file "Inbox") "* %U %?\n%i\n%a"
          :prepend t)
         ("pc" "Project-local changelog" entry
          (file+headline +org-capture-project-changelog-file "Unreleased")
          "* %U %?\n%i\n%a" :prepend t)
         ("o" "Centralized templates for projects")
         ("ot" "Project todo" entry #'+org-capture-central-project-todo-file
          "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
         ("on" "Project notes" entry #'+org-capture-central-project-notes-file
          "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
         ("oc" "Project changelog" entry #'+org-capture-central-project-changelog-file
          "* %U %?\n %i\n %a" :heading "Changelog" :prepend t))))
#+end_src

#+RESULTS:
| t | Personal todo | entry | (file+headline +org-capture-todo-file Inbox) | * TODO %? |

*** Improve org-capture dialog
#+BEGIN_SRC elisp
(after! org-capture
    (defun org-capture-select-template-prettier (&optional keys)
    "Select a capture template, in a prettier way than default
    Lisp programs can force the template by setting KEYS to a string."
    (let ((org-capture-templates
            (or (org-contextualize-keys
                (org-capture-upgrade-templates org-capture-templates)
                org-capture-templates-contexts)
                '(("t" "Task" entry (file+headline "" "Tasks")
                    "* TODO %?\n  %u\n  %a")))))
        (if keys
            (or (assoc keys org-capture-templates)
                (error "No capture template referred to by \"%s\" keys" keys))
        (org-mks org-capture-templates
                "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
                "Template key: "
                `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
    (advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier))

#+END_SRC

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but It would be even nicer with a smaller frame, and
no modeline.
#+BEGIN_SRC emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
      ;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+END_SRC
* Projectile
** Project Search Path
Search for projects in  ~~/Code/~, but only one level deep.
#+begin_src elisp
(setq projectile-project-search-path '(("~/Code/" . 1)))
#+end_src
* Development
** Language-Specific Settings
*** Web Dev (JS/TS/CSS)
**** Testing
***** Jest.el
#+begin_src elisp :tangle packages.el
(package! jest)
#+end_src

#+begin_src elisp
(use-package! jest
  :after (typescript-mode js-mode typescript-tsx-mode)
  :hook (typescript-mode . jest-minor-mode))
#+end_src
**** Svelte
#+begin_src elisp :tangle packages.el
(package! svelte-mode)
#+end_src

#+begin_src elisp
(use-package! svelte-mode
    :mode "\\.svelte\\'")
#+end_src

**** Vue
***** LSP
The package lsp-mode has an issue with volar in version 8.0.0, so until the
issues are in the next release of lsp-mode (and doom), I'm unpinning the
package.

#+begin_src elisp :tangle packages.el
(unpin! lsp-mode)
#+end_src

To get lsp support working, there needs to be a ~.volarrc~ file in the project's
root directory.

***** Formatting

Remove 1 space padding from <script> tags, set indent to 2.

#+begin_src elisp
(with-eval-after-load 'web-mode
  (setq web-mode-script-padding 0)
  (setq web-mode-style-padding 0)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-markup-indent-offset 2))
#+end_src

***** Folding
**** Astro
#+begin_src elisp :tangle packages.el
(package! astro-ts-mode)
#+end_src

Because ~astro-ts-mode~ uses treesitter, treesitter needs to be set up to handle
~.astro~ files properly.

#+begin_src elisp
(setq treesit-language-source-alist
      '((astro "https://github.com/virchau13/tree-sitter-astro")
        (css "https://github.com/tree-sitter/tree-sitter-css")
        (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")))
#+end_src

Define Astro as a derived mode for ~.astro~ files.

#+begin_src elisp
(define-derived-mode astro-mode web-mode "astro")
(setq auto-mode-alist
      (append '(("\\.astro\\'" . astro-mode))
              auto-mode-alist))
#+end_src

Register the astro-ls binary for lsp support.

#+begin_src elisp
(with-eval-after-load 'lsp-mode
  (add-to-list 'lsp-language-id-configuration '(astro-mode . "astro"))
  (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection '("astro-ls"))
                    :activation-fn (lsp-activate-on "astro")
                    :server-id 'astro-ls)))
#+end_src


**** Tailwind
Add the tailwind lsp package
#+begin_src elisp :tangle packages.el
(package! lsp-tailwindcss
  :recipe (:host github
           :repo "merrickluo/lsp-tailwindcss"))
#+end_src

...and use it
#+begin_src elisp
(use-package! lsp-tailwindcss
  :defer t
  :init
  (setq lsp-tailwindcss-add-on-mode t))
#+end_src

**** Code formatting
Set typescript file indentation to be 2 levels by default.
#+begin_src elisp
(setq typescript-indent-level 2)
#+end_src

**** TODO Typescript REPL
*** Nix
**** nix-mode.el
[[https://github.com/NixOS/nix-mode][Nix-mode]] is a major mode for editing nix expressions. It comes with a variaty of submodules
#+begin_src elisp
(use-package! nix-mode
  :mode "\\.nix\\'")
#+end_src

***** nix.el
Nix.el contains some miscellanious tools. Interactive functions include:

- nix-unpack - unpack source of a Nix attribute.
  Available via ~M-x nix-unpack~ followed by the nix path and attribute path.

- nix-build - functions similar to ~M-x compile~. Will build in the current
  directory if it contains a ~default.nix~.

There are also basic functions for interacting with nix - some variables are
provided to point to Nix binaries that can be used in Lisp code.

- ~nix-executable~
- ~nix-build-executable~
- ~nixinstantiate-executable~
- ~nix-store-executable~
- ~nix-shell-executable~

Also, a function ~nix-system~ is provided to get the current system (the way Nix
detects it).

***** nix-flake.el

Uses transient.el to provide a magit-like interface for supporting flake
commands.
Using ~M-x nix-flake~ commands can be run on the current flake, whereas ~M-x
~nix-flake-init~ can initialize a flake from a atemplate.

***** nix-repls.el

Provides an interface for completion, nused by nix-company.el. Secondly it
provides an interactive function to open a repl via ~M-x nix-repl~

***** nix-store.el

Displays information about the store path including logs associated with a
derivation.

***** nix-prettify-mode.el

Improves display of store paths.

**** nix-buffer
Adds an emacs command to modify the buffer environment according to a Lisp
expression buily by nix.


*** Python
**** Poetry
After years of frustration, I'm finally content with setting up and managing
projects in the Python ecosystem, thanks to Poetry. It's a great tool, and
luckily, there is excellent integration with Emacs.

#+begin_src elisp :tangle packages.el
(package! poetry)
#+end_src

**** Run pytest in virtualenv
python-pytest does not use the virtualenv's binary by default. As a fix, I'm
adding a hook to python-mode to set the correct executable - since python-mode
plays nicely with direnv.

#+begin_src elisp
(add-hook! python-mode
  (advice-add 'python-pytest-file :before
              (lambda (&rest args)
                (setq-local python-pytest-executable
                            (executable-find "pytest")))))
#+end_src

*** Markdown
**** Code blocks
To set up code-highlighting in markdown code blocks, I need multiple major modes in one buffer. The package polymode promises to allow that:
#+begin_src elisp
;; (use-package! polymode
;; (use-package! poly-markdown)
#+end_src

**** Live Preview
Impatient-Mode is a package to live-preview HTMl, and with a trick, it can be
used to preview markdown.

First, install the dependency.
#+begin_src elisp :tangle packages.el
(package! impatient-mode)
#+end_src

To use it:

- Start an emacs' web server with M-x httpd-start.
- Start impatient mode in the buffers you're interested to live preview: M-x impatient-mode.
- Open your browser to localhost:8080/imp. You'll see the list of buffers with the mode enabled. Click on one: you see live rendering of the buffer.

Then, set up a markdown-html function.

#+begin_src elisp
  (defun markdown-html (buffer)
    (princ (with-current-buffer buffer
      (format "<!DOCTYPE html><html><title>Impatient Markdown</title><xmp theme=\"united\" style=\"display:none;\"> %s  </xmp><script src=\"http://ndossougbe.github.io/strapdown/dist/strapdown.js\"></script></html>" (buffer-substring-no-properties (point-min) (point-max))))
    (current-buffer)))
#+end_src

*** Terraform
There are two competing lsp servers for Terraform with support in Emacs, but,
although ~terraform-lsp~ is the more featurerich, I'm sticking with ~terraform-ls~
since it's not only more reliable, but seems to not work with TF versions above 0.12.
But still, ~terraform-lsp~ is a good alternative, with some nice- to- haves.

#+begin_src elisp
(setq lsp-terraform-ls-enable-show-reference t)
(setq lsp-semantic-tokens-enable t)
(setq lsp-semantic-tokens-honor-refresh-requests t)
#+end_src
** Tools
*** Code Completion
Since it's already integrated into Doom Emacs, I'm using company for code
completion.

**** Handling
I don't want any delay in showing suggestions, unless I'm writing a string or a
comment, then I want company to not show any suggestions at all.

#+begin_src elisp
(setq company-idle-delay 0.1 ;; How long to wait before popping up
      company-minimum-prefix-length 1 ;; Show the menu after one key press
      company-tooltip-limit 10 ;; Limit on how many options to display
      company-tooltip-align-annotations t ;; Align annotations to the right
      company-require-match nil           ;; Allow free typing
      company-selection-wrap-around t ;; Wrap around to beginning when you hit bottom of suggestions
      )
#+end_src

**** Backends
A backend is responsible for providing the completion suggestions. As I'm using
LSP where possible, and I don't want to use snippets in that way, I'm going to
keep the list of backends very short.

#+begin_src elisp
(after! lsp-mode
  (setq company-backends '(company-capf)))
#+end_src

***** Mode-Specific Backends
The dictionary completion in ~org-mode~ just annoys me, and it seems to
significantly slow down typing, so I'm disabling ~company-ispell~ (hopefully) everywhere.

#+begin_src elisp
(setq company-ispell-available nil)
#+end_src

**** Looks
For the icons, I'm using VSCode icons. The nomenclature is a little confusing,
to determine, what to put in the margin, company has to execute a function. So
using the function ~company-vscode-dark-icons-margin~ here means just setting
those icons as what's being displayed.

#+begin_src elisp
(setq company-format-margin-function #'company-vscode-dark-icons-margin)
#+end_src

**** Snippets
*** Copilot
**** Getting a Node 16 binary
Currently, this plugin only works with an older version of node (16) installed,
which is handled via nvm. Since I'm using this concept on multiple machines, it
makes sense to get the nvm version's path programatically.

Since I'm installing all my emacs modules via nix, the ~:recipe~ declaration is
useless and ist just left in so that this config will still work on its own.

The actual package is defined in my nix config.
#+begin_src elisp :tangle packages.el
(package! copilot :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
#+end_src

#+begin_src elisp :tangle packages.el
(package! nvm)
#+end_src


First, I'm defining a helper function to call nvm after sourcing my zsh config
(which provides nvm).
#+begin_src elisp
(defun call-nvm (args &optional as-string)
  (let ((nvm-command "source $XDG_CONFIG_HOME/zsh/.zshrc && nvm"))
    (if as-string
        (shell-command-to-string (concat nvm-command " " args))
      (shell-command (concat nvm-command " " args)))))
#+end_src

Then, I'm using the ~call-nvm~ function to create a function that will install
node 16 via ~nvm~ if it's not already installed.
#+begin_src elisp
(defun install-node-if-missing ()
  (if (not (eq 0 (call-nvm "ls 16")))
      (call-nvm "install 16")))
#+end_src


**** Loading the package

For reusability, I'm defining a function that will load the copilot package with
some keybindings.

#+begin_src elisp
(defun load-copilot ()
  (use-package! copilot
    :hook ((prog-mode text-mode) . copilot-mode)
    :bind (:map copilot-completion-map
           ("C-SPC" . 'copilot-accept-completion)
           ("C-<spc>" . 'copilot-accept-completion)
           ("C-S-p" . 'copilot-previous-completion)
           ("C-S-n" . 'copilot-next-completion))))
#+end_src

Finally, I'm checking for the ~copilot-node-exectuable~. When building Doom Emacs
via nix, I'm injecting a node16 path in the nix store, so setting the node
executable here is only necessary if ~copilot-node-executable~ isn't already set.

#+begin_src elisp
(if (and (boundp 'copilot-node-executable) (file-exists-p copilot-node-executable))
    (load-copilot)
    (nvm-use "16" (lambda ()
                   (setq copilot-node-executable
                         (concat
                          (nth 1 (nvm--find-exact-version-for "16"))
                          "/bin/node"))
                   (load-copilot))))
#+end_src

In insert mode, I'm binding  ~C-SPC~ to accept the complete suggestion. I'm also binding ~C-S-p~ and ~C-S-n~ to navigate through the suggestions.

Additionally, I'm binding ~i g s~ to show the suggestions, and ~i g c~
to insert the suggestion for use in normal mode, and ~t p~ to toggle Copilot.

#+begin_src elisp
(map! :leader
      (:prefix-map ("i" . "insert")
       (:prefix ("g" . "github copilot")
        :desc "Show Copilot Completion" "s" #'copilot-complete
        :desc "Insert Copilot Completion" "c" #'copilot-accept-completion))
      (:prefix ("t" . "toggle")
       :desc "Toggle Copilot" "p" #'copilot-mode))
#+end_src

*** Debugging
Doom Emacs has a debugger module which uses ~dap-mode~ under the hood.

**** Language-Specific Debugger settings
***** Python

I'm using debugpy for python.

#+begin_src elisp
(setq dap-python-debugger 'debugpy)
#+end_src

**** Fixes
***** Fix Doom "+debugger/start"

By default, ~+debugger/start~ will look for the last configuration set in the
project's doom-store - which has to be cleared manually to reset. This function
will remove the debugger configuration from the doom-store.

#+begin_src elisp
;;;###autoload
(defun +debugger/clear ()
  "Clear the debugger configuration from the doom-store."
  (interactive)
  (doom-store-rem (doom-project-root) "+debugger"))
#+end_src

The old function is renamed to ~+debugger/repeat~.

#+begin_src elisp
(setq debugger-start-copy (symbol-function '+debugger/start))

;;;###autoload
(defun +debugger/repeat (arg)
  "Start the debugger."
  (interactive)
  (funcall debugger-start-copy arg))
#+end_src

And ~+debugger/start~  is redefined to clear the configuration before starting.

#+begin_src elisp
;;;###autoload
(defun +debugger/start (arg)
  "Launch a debugger session.
Launches the last used debugger, if one exists. Otherwise, you will be prompted
for what debugger to use. If the prefix ARG is set, prompt anyway."
  (interactive "P")
  (message arg)
  (+debugger--set-config (+debugger-completing-read))
  (+debugger/start-last))
#+end_src

***** Missing fringes in dap-mode
When running the dap-mode debugger, for some reason, the code window's fringes
get set to 0 width. This can be fixed with a workaround by setting the window's
buffer again via ~set-window-buffer~. Since this only should happen on windows
with file buffers, we need some helper functions to get the correct window.

****** Get the window containing a file buffer

Since there's only one window with a file buffer when running the debugger, this
can be kept fairly simple.

#+begin_src elisp
(defun get-window-with-file-buffer ()
  "Get the window with a file buffer."
  (seq-find (lambda (window)
              (buffer-file-name (window-buffer window)))
            (window-list)))
#+end_src

****** Reset file buffer window

Using the helper function, we can reset the file window's buffer.

#+begin_src elisp
(defun reset-file-window-buffer ()
  "Reset the file window's buffer."
  (let ((window (get-window-with-file-buffer)))
    (when window
      (set-window-buffer window (window-buffer window)))))

#+end_src

****** Add reset to window configuration change hook

Having tried multiple dap hooks to no avail, I've resigned to just resetting the
file window's buffer on every window configuration change. This can be achieved
with the ~window-configuration-change-hook~. Here, I only want to have the hook
active when in a dap session, so I'm adding the reset function after the dap
session has been created and removing it when the session is terminated.

#+begin_src elisp
(defun add-reset-file-window-buffer-hook (&rest args)
  "Add the reset-file-window-buffer function to the window-configuration-change-hook."
  (add-hook 'window-configuration-change-hook 'reset-file-window-buffer))

(defun remove-reset-file-window-buffer-hook (&rest args)
    "Remove the reset-file-window-buffer function from the window-configuration-change-hook."
    (remove-hook 'window-configuration-change-hook 'reset-file-window-buffer))

(add-hook 'dap-mode-hook 'add-reset-file-window-buffer-hook)
#+end_src

**** Keybindings
#+begin_src elisp
(map! :leader
      (:prefix-map ("d" . "debugger")
       :desc "Debug" "d" #'dap-debug
       :desc "Next" "n" #'dap-next
       :desc "Step in" "i" #'dap-step-in
       :desc "Step out" "o" #'dap-step-out
       :desc "Continue" "c" #'dap-continue
       :desc "Restart" "r" #'dap-restart-frame
       :desc "Disconnect" "D" #'dap-disconnect
       :desc "Evaluate" "e" #'dap-eval
       :desc "Add Expression" "a" #'dap-ui-expressions-add
       (:prefix ("b" . "breakpoints")
        :desc "Toggle" "t" #'dap-breakpoint-toggle
        :desc "Add" "a" #'dap-breakpoint-add
        :desc "Delete" "d" #'dap-breakpoint-delete
        :desc "Set condition" "c" #'dap-breakpoint-condition
        :desc "Set log message" "m" #'dap-breakpoint-log-message
        :desc "Set hit condition" "h" #'dap-breakpoint-hit-condition)))

#+end_src
*** Syntax Checking
For some reason, flycheck - especially when checking web files - is really slow.
To alleviate, it should only check the syntax on file-save.

#+begin_src elisp
(setq flycheck-syntax-automatically '(save-mode-enable))
#+end_src

*** LSP
For the LSP settings, I'm using the doom lsp module, which defaults to lsp-mode,
and lsp-ui. The alternative, eglot, would mean I'd have to set up the language
servers myself instead of relying on ~M-x lsp-install~. Although I have started to
work on a nix-workflow to install node-packages for that purpose, the
the ease of use of ~M-x lsp-install~ and the possibility of using lsp-ui means
I'll stick to lsp-mode for now.

Most of the language-specific settings are already defined under [[*Language-Specific Settings]].
Here, I'll define some general settings.
**** Performance
Using plists should increase the LSP performance.

#+begin_src elisp
(setq lsp-use-plists 't)
#+end_src

**** Handling
Set ~capf~ as completion provider.

#+begin_src elisp
(setq lsp-completion-provider :capf)
#+end_src

Don't show completion item detail

#+begin_src elisp
;; (setq lsp-completion-show-detail t)
#+end_src

Show completion item kind

#+begin_src elisp
(setq lsp-completion-show-kind t)
#+end_src

Automatically start LSP on file open, guess root.
#+begin_src elisp
;; (setq lsp-auto-guess-root t)
;; (add-hook 'prog-mode-hook #'lsp-deferred)
#+end_src

**** UI
Although I like using ~lsp-ui-doc~, I don't want it to appear every time I'm
hovering. Having a keybinding to glance at the documentation is fine for me.

#+begin_src elisp
(map! :leader
      (:prefix ("c" . "code")
       :desc "Glance at documentation" "g" #'lsp-ui-doc-glance))
#+end_src

Enable lenses
#+begin_src elisp
(setq lsp-lens-enable t)
#+end_src

Enable headerline with breadcrumbs.
#+begin_src elisp
(setq lsp-headerline-breadcrub-enable t)
#+end_src

Disable eldoc, as it does not look that good and mostly serves as a distraction.
#+begin_src elisp
(setq lsp-eldock-enable-hover nil)
#+end_src

Same with signature help, as well as help documentation
#+begin_src elisp
(setq lsp-signature-auto-activate nil)
(setq lsp-signature-render-documentation nil)
#+end_src

Set lsp-ui-doc sizing
#+begin_src elisp
(setq lsp-ui-doc-max-height 20
      lsp-ui-doc-max-width 80)
#+end_src

*** Git
Doom Emacs comes with Magit.

**** Disable Evil-Mode in timemachine mode
#+begin_src elisp
(eval-after-load 'git-timemachine
  '(progn
     (evil-make-overriding-map git-timemachine-mode-map 'normal)
     ;; force update evil keymaps after git-timemachine-mode loaded
     (add-hook 'git-timemachine-mode-hook #'evil-normalize-keymaps)))
#+end_src
*** Documentation
**** Devdocs
Devdocs (https://elpa.gnu.org/packages/devdocs.html) is a package for viewing
documentations, similar to Dash (https://kapeli.com/dash).

The documentation is hosted on https://devdocs.io/ and is open source. Sadly,
Devdocs can not read docsets from Dash.

***** Install

#+begin_src elisp :tangle packages.el
(package! devdocs)
#+end_src

***** Configuration
Add keybindings under ~SPC o D~ ("o" for "open", "D" for "Devdocs").

#+begin_src elisp
(map! :leader
      (:prefix ("D" . "devdocs")
       :desc "Open devdocs" "o" #'devdocs-peruse
       :desc "Search devdocs" "l" #'devdocs-lookup
       :desc "Install devdocs set" "i" #'devdocs-install))
#+end_src


**** Dash

Dash-Docs (https://github.com/dash-docs-el/dash-docs) is a package for viewing
Dash docsets.

***** Install

#+begin_src elisp :tangle packages.el
;; (package! dash-docs)
#+end_src

***** Configuration
Put Docsets in share dir
#+begin_src elisp
;; (setq dash-docs-docsets-path "$HOME/.local/share/docsets")
#+end_src
*** GPT
GPT.el (https://github.com/stuhlmueller/gpt.el) is a package for interacting
with OpenAI's GPT-3 API.

**** Install
#+begin_src elisp :tangle packages.el
(package! gpt)
#+end_src

**** Configuration
#+begin_src elisp
(setq gpt-openai-key (password-store-get "bitwarden/openai-gpt-key"))
(setq gpt-openai-engine "code-davinci-002")
(use-package! gpt)
#+end_src

*** Quarto
Quarto (https://quarto.org/) is a package for writing literate programming,
based on Pandoc.

#+begin_src elisp :tangle packages.el
(package! quarto-mode)
#+end_src

#+begin_src elisp
(use-package quarto-mode
  :mode (("\\.Rmd" . poly-quarto-mode)))
#+end_src
* UI
** Theming
*** Doom Themes
#+begin_src elisp :tangle packages.el
(package! doom-themes)
#+end_src

*** Catppuccin
Catppuccin is a color scheme using pastel colors. It's available for a variety
of tools.

#+begin_src elisp :tangle packages.el
(package! catppuccin-theme)
#+end_src

Catppuccin has different "flavors", which can be set via the ~catppuccin-flavor~
variable.

- ~latte~: Light theme
- ~frappe~: Dark theme, muted colors
- ~macciato~: Dark theme, semi-muted colors
- ~mocha~: (default) Dark theme, vibrant colors

Since the default is a bit too vibrant for my taste, I'm setting the flavor to ~frappe~.
#+begin_src elisp
(setq doom-theme 'catppuccin)
(setq catppuccin-flavor 'frappe)

(setq doom-themes-treemacs-theme "doom-colors")

(with-eval-after-load 'doom-themes
  (doom-themes-treemacs-config))
#+end_src
*** Nano
Nano is a minimalistic theme for emacs, and it is absolutely gorgeous. Although
it lacks the features I need, I was always a fan of the look. Now, it's possible
to enjoy the best of both worlds by theming Doom to look like Nano.

The only issue is that loading ~doom-nano-testing~ currently does more than just
adjust the colorscheme, and while I like the minimal top modeline, I'd like to
have a choice. In the future, I will pick and choose from Nano to adjust the layout.

#+begin_src elisp
;; (add-to-list 'load-path "~/Code/doom-nano-testing") (require 'load-nano)
;; (setq doom-themes-treemacs-theme "doom-atom")
#+end_src

*** Misc Themes
**** Grayscale
#+begin_src elisp :tangle packages.el
(package! grayscale-theme)
#+end_src
It leetle much on the warm side for my tastes...
**** Tao Themes
Very appealing, minimalistic themes.

#+begin_src elisp :tangle packages.el
(package! tao-theme)
#+end_src

**** Ewal
Ewal (https://github.com/cyruseuros/ewal) is similar to (and builds upon)
pywal, but for Emacs. It allows you to set the theme of Emacs based on the
colors of your wallpaper. (Or other pictures).

#+begin_src elisp :tangle packages.el
(package! ewal)
(package! ewal-doom-themes)
#+end_src

#+begin_src elisp
(use-package ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p nil
              ewal-built-in-palette "sexy-material"))
#+end_src



*** Theme Magic
In a stark difference to the other solutions, which wants to adjust Emacs to the buty of the
rest of the world, Theme Magic (https://github.com/jcaw/theme-magic), which uses
PyWal (again!) to adjust every color it can to match your glorious editor.

#+begin_src elisp :tangle packages.el
(package! theme-magic)
#+end_src
*** Autothemer
More than auto"magically" generating hew themes, Autothemer
(https://github.com/jasonm23/autothemer) is more of a tool for those proficient
in themeing or those who want to be. a package for
generating color schemes, although it is more flexible than ewal or pywal.

#+begin_src elisp :tangle packages.el
(package! autothemer)
#+end_src

*** Base 16 Themes
Since they rely on only the 16 base terminal colors, base 16 themes are very
popular and make it easy to have a harmonized look across all your programs.
Fortunately, there is a base 16 theme for Doom Emacs, which stems from the
"Tinted Themeing project" (https://github.com/tinted-theming/home).

#+begin_src elisp :tangle packages.el
(package! base16-theme)
#+end_src

Some of the themes have a bit too less contrast for my taste. I think  the issue
is that all 16 colors are taken 'as-is', whereas it should be possible to
create a color scheme with more nuance via color correcting the applied colors.

~kurecolor~ seems to be a library aimed exactly at such a purpose.

#+begin_src elisp :tangle packages.el
(package! kurecolor)
#+end_src

**** TODO: Implement more complex color schemes based on base16 colors

** Modeline
*** Doom Modeline
Allow for more characters in the branch name

#+begin_src elisp
(setq doom-modeline-vcs-max-length 50)
#+end_src

#+begin_src elisp
(setq doom-modeline-hud t)
#+end_src

*** Nano Modeline
:PROPERTIES:
:header-args: :tangle no
:END:
Nicolas P. Rougier spent a lot of effort creating beautiful, minimalistic themes
for Emacs - some geared for scientific work, some for writing prose. While they
are really pretty to look at, in my day to day business, they are a bit too
minimalistic.

One thing however that always stuck out for me was the brilliant NANO modeline.

Ronisbr (https://github.com/ronisbr/doom-nano-modeline) attempted to port it to
DOOM Emacs.

#+begin_src elisp :tangle packages.el
(package! doom-nano-modeline
  :recipe (:host github
  :repo "ronisbr/doom-nano-modeline"))
#+end_src

#+begin_src elisp
(use-package! doom-nano-modeline
  :config
  (doom-nano-modeline-mode 1)
  (global-hide-mode-line-mode 1))
#+end_src

**** Result:
I'm a bit disappointed. It's very minimalistic, but without the colorscheme
hiding the rough edges between e.g. treemacs and the modeline (which is still
squished to the top of the page), the loss in useful information is not worth
it.

I'll keep it around for a bit, but I'm going back to doom modeline.

** Spacing
*** General Padding
The way windows have been close together always kind of botheres me. Luckily,
there's a package that seems to halp with simple padding, without any
contortions.

#+begin_src elisp :tangle packages.el
(package! spacious-padding)
#+end_src

TO actually use it, I need to find a better color scheme, where the edges aren't
as jarring, but it's very promising. The individual spacings can be adjusted
with the following:$HOME

#+begin_src elisp
(setq spacious-padding-width '(:internal-border-width 10 :right-divider-width 30 :scroll-bar-width 5))
#+end_src

(The actual values obviously need to be tweaked though)

** Dashboard

I prefer something more simpler - also the dashboard can display SVGs:
#+begin_src elisp
(setq fancy-splash-image (concat doom-private-dir "splash-logos/emacs-logo-cutout.svg"))
#+end_src
# I don't really have much use for the Doom dashboard, so I'm replacing it with
# the package [[https://github.com/emacs-dashboard/emacs-dashboard][Emacs Dashboard]].

# - Install the package.
# #+begin_src elisp :tangle packages.el
# (package! dashboard)
# #+end_src

# Initialize the package
# #+begin_src elisp
# (use-package! dashboard
#   :ensure t
#   :config
#   (dashboard-setup-startup-hook))

# #+end_src

# #+RESULTS:
# : t

# Show just a small text as startup banner, center the content and add a mix of widgets.
# #+begin_src  elisp
# (setq dashboard-startup-banner-logo-title "(emacs)")
# (setq dashboard-startup-banner 2)
# (setq dashboard-set-navigator t)
# (setq dashboard-center-content t)
# (setq dashboard-items '((bookmarks . 5)
#                         (agenda . 5)))
# (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
# (setq dashboard-set-heading-icons t)
# (setq dashboard-set-file-icons t)
# (setq dashboard-set-navigator t)
# (setq dashboard-set-init-info t)
# (setq dashboard-footer-icon (all-the-icons-octicon "dashboard"
#                                                    :height 1.1
#                                                    :v-adjust -0.05
#                                                    :face 'font-lock-keyword-face))
# (setq dashboard-projects-switch-function 'projectile-persp-switch-project)
# (setq doom-fallback-buffer-name "*dashboard*")
# #+end_src

# #+RESULTS:
# : *dashboard*

** Which-Key
Which Key is a package that displays the keybindings for the current command in
a popup. Especially in combination with evil-mode - which has a fantastic
integration, it is very useful, especially for rarely used commands.

Per default, which-key displays the keybindings for the current command in a
popup at the bottom of the screen. This can be changed to either the side or the
minibuffer, but all of those options don't appeal to me. Luckily, there is a
[[https://github.com/tumashu/posframe][Posframe]] integration. Posframe is a package that displays a buffer in a child
frame. This allows for much more flexibility in the placement of the popup.

#+begin_src elisp :tangle packages.el
;; (package! which-key-posframe)
#+end_src

There are some issues regarding the frame's height - sometimes the content is
cut off. This seems to be an ongoing issue, as per [[https://github.com/yanghaoxie/which-key-posframe/issues/5][this Github issue]].

The mentioned solution to use posframe's arghandler does not work anymore, as
it is depcrecated. The recommended alternative is to use advise.

#+begin_src elisp
;; (defun wjb/posframe-arghandler (buffer-or-name arg-name value)
;;   (let ((info '(:internal-border-width 2 :width 500 :height 48)))
;;     (or (plist-get info arg-name) value)))
;; (setq posframe-arghandler #'wjb/posframe-arghandler)
#+end_src

** Ivy
Ivy is a package that provides a completion framework for Emacs. It is
particularly useful for commands that require a lot of input, such as ~M-x~ or
~find-file~.

It is fast and leightweight, and there are a lot of packages that integrate with
it.

*** Keybindings

Some of the default keybindings feel odd to me, for instance the tab key
behavior. I'm still trying for a way to have the same behavior as in a terminal,
i.e. multiple tab presses start cycling through the completion candidates.

#+begin_src elisp
;; (define-key ivy-minibuffer-map (kbd "TAB") 'ivy-partial)
;; (define-key ivy-minibuffer-map (kbd "<return>") 'ivy-alt-done)
#+end_src

*** Looks
**** All-The-Icons Ivy Rich

Per default, Ivy looks a little bland. All-The-Icons-Ivy Richt is an alternative
to All-The-icons-Ivy (which had some issues with my setup)


#+begin_src elisp :tangle packages.el
(package! all-the-icons-ivy-rich)
#+end_src

#+begin_src elisp
(use-package! all-the-icons-ivy-rich
  :defer t
  :after counsel-projectile
  :init (all-the-icons-ivy-rich-mode +1)
  :config
  (setq all-the-icons-ivy-rich-icon-size 0.8))
#+end_src

**** Ivy-Postframe
:LOGBOOK:
CLOCK: [2023-02-10 Fri 12:39]--[2023-02-10 Fri 12:41] =>  0:02
:END:

Doom Emacs already has Ivy-Postframe enabled, so there are just some tweaks to
be made.

Per default, the window has a dynamic width, which means that when typing, it
will rapidly change its width, which is not very pleasant to look at.
#+begin_src elisp
(setq ivy-posframe-width 80)
#+end_src

** Treemacs

Treemacs is a file and project explorer similar to NeoTree or vim’s
NerdTree, but largely inspired by the Project Explorer in Eclipse.
It shows the file system outlines of your projects in a simple tree layout
allowing quick navigation
and exploration, while also possessing basic file management utilities.

*** Icons
Doom switched from ~treemacs-all-the-icons~ to ~treemacs-nerd-icons~ recently -
though the icons look weird per default. For some reason, the fix discussed [[https://discourse.doomemacs.org/t/ugly-icons-in-treemacs/4147][here]] does not work, so I'm applying it manually.

#+begin_src elisp :tangle packages.el
(package! treemacs-nerd-icons :pin "9876cb478145a0ec4e36f64ff6583f3de7126216")
#+end_src

#+begin_src elisp
(use-package! treemacs-nerd-icons
  :after treemacs
  :config (treemacs-load-theme "nerd-icons"))
#+end_src

** Vertico
Prefix the current candidte with an arrow
#+begin_src elisp
(defun minibuffer-format-candidate (orig cand prefix suffix index _start)
  (let ((prefix (if (= vertico--index index)
                    "  " "   ")))
    (funcall orig cand prefix suffix index _start)))

(advice-add #'vertico--format-candidate
            :around #'minibuffer-format-candidate)
#+end_src

Don't show results count
#+begin_src elisp
(setq vertico-count-format nil)
#+end_src

Make vertico-posframe a little wider
#+begin_src elisp
(setq vertico-posframe-width 200)
#+end_src

** Xwidget Webkit
*** Emacs xwidget-webkit enhancement suite

Xwwp (https://github.com/BlueFlo0d/xwwp) is a package that enhances the
xwidget-webkit browser.

#+begin_src elisp :tangle packages.el
(package! xwwp :recipe (:host github :repo "BlueFlo0d/xwwp"))
(package! xwwp-follow-link-ivy)
(package! ctable)
#+end_src

#+begin_src elisp
(use-package! xwwp-full
  :after xwidget-webkit
  :custom
  (xwwp-follow-link-completion-system 'ivy)
  :bind (:map xwidget-webkit-mode-map
              ("f" . xwwp-ace-toggle)
              ("v" . xwwp-follow-link)))
#+end_src
* Performance
Various tweaks to improve the overall performance.
** Raise the GC-Cons threshold
#+begin_example elisp
(setq gc-cons-threshold (* 1024 1024 1024)) ;; 1G
#+end_example

** Increase the amount of data which Emacs reads from the process
#+begin_src elisp
(setq read-process-output-max (* 4 1024 1024)) ;; 4mb
#+end_src

* Unsorted Packages
#+begin_src elisp :tangle packages.el

(package! dap-mode)

;; HTTP requests via babel
(package! ob-http :pin "b1428ea2a63bcb510e7382a1bf5fe82b19c104a7")

;; OrgRoam visualization / webapp

;; automatic latex rendering

;; export github markdown
(package! ox-gfm :pin "99f93011b069e02b37c9660b8fcb45dab086a07f")

;; K8s
(package! k8s-mode)

;; Copilot
;; (package! copilot
;;   :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))

;; Multiple major modes in one buffer
(package! polymode)
(package! poly-markdown)

#+end_src
