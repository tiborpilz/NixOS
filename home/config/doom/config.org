#+PROPERTY: header-args elisp :tangle ./config.el :results silent
#+TITLE: Doom Emacs Config

* Base Settings
** Personal data

Set Name and mail adress
#+begin_src elisp
(setq user-full-name "Tibor Pilz"
      user-mail-address "tibor@pilz.berlin")
#+end_src

** Font settings

#+begin_src elisp
(setq doom-font (font-spec :family "FiraCode Nerd Font" :size 14 :weight 'normal)
      doom-big-font (font-spec :family "FiraCode Nerd Font" :size 32 :weight 'light)
      doom-unicode-font (font-spec :family "FiraCode Nerd Font" :size 16 :weight 'light)
      doom-variable-pitch-font (font-spec :family "DejaVu Serif" :size 18 :weight 'light))
#+end_src

** Line numbers

Since I'm using Evil/vim-keybindings, I prefer relative line numbers. ~'visual~ is
a different way of relative line numbers, where folded lines are not counted.

#+begin_src elisp
(setq display-line-numbers-type 'visual)
#+end_src

** Tab width

#+begin_src elisp
(setq tab-width 2)
#+end_src

** Splash Screen
*** Splash Image

I've created a custom SVG with transparency and shadow effects that should go
well with a variety of color schemes.
#+begin_src elisp
(setq fancy-splash-image (concat doom-private-dir "splash-logos/emacs-logo-cutout.svg"))
#+end_src

** Title

I'm setting the title to be just "Emacs"

#+begin_src elisp
(setq frame-title-format "%b - Emacs")
#+end_src

** Password Store location

I'm using ~pass~ (synced to my Bitwarden via a custom utility) to store/retrieve
secrets. Instead of the default location, my password storage lives at
~$HOME/.local/share/password-store~.

For ~password-store~ to work correctly, this needs to be set up.

#+begin_src elisp
(setq auth-source-pass-filename
      (concat (getenv "HOME") "/.local/share/password-store"))
#+end_src

* Utils

For efficiently writing my config, I need some utils.

** Add-Hooks

Small utility to add a function to multiple hooks at once.

#+begin_src elisp
(defun add-hooks (hook-list function)
  "Add FUNCTION to all hooks in HOOK-LIST."
  (dolist (hook hook-list)
    (add-hook hook function)))
#+end_src

* Org Mode
** Base Settings

I'm using ~~/org~ as my base directory for org files. (This is then synced across devices).


#+begin_src elisp
(setq org-directory "~/org/")

(setq org-use-property-inheritance t)
(setq org-log-done 'time) ; Log time when task completes
(setq org-list-allow-alphabetical t)       ; a, A, a) A) list bullets)
(setq org-catch-invisible-edits 'smart) ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{})

(setq org-return-follows-link 1)
(setq calendar-week-start-day 1) ;; start on monday
(setq org-agenda-include-diary t)
#+end_src

** Visual improvements
*** Headlines

Set headlines to the foreground color, successively darkened:

#+begin_src elisp
(defun set-org-headline-color ()
  "Set the org headline colors to darker variants of the foreground color."
  (dotimes (i 8)
    (set-face-foreground (intern (format "org-level-%d" (1+ i))) (doom-color 'fg)))
  (set-face-foreground 'org-document-title (doom-color 'fg)))

(add-hook 'org-mode-hook 'set-org-headline-color)
#+end_src

Hide leading stars:

#+begin_src elisp
(setq org-hide-leading-stars nil)
#+end_src

Indent content based on headline level:

#+begin_src elisp
(setq org-startup-indented nil)
#+end_src

*** Fonts

Org mode should use a variable pitch font for better readability.

#+begin_src elisp
(add-hook 'org-mode-hook #'mixed-pitch-mode)
#+end_src

Line spacing should be higher in org-mode than in "code" modes.

#+begin_src elisp
(add-hook 'org-mode-hook
          (lambda () (setq line-spacing 0.2)))
#+end_src

*** Org-Modern

Org-modern (https://github.com/minad/org-modern) contains a lot of nice visual
improvements for org-mode.

#+begin_src elisp :tangle packages.el
(package! org-modern)
#+end_src

#+begin_src elisp
(use-package! org-modern
  :defer t
  :config
  (setq org-modern-label-border 0.1
        org-modern-star 'replace))
#+end_src

Set up org-modern

#+begin_src elisp
(setq
  org-auto-align-tags nil
  org-tags-column 0
  org-catch-invisible-edits 'show-and-error
  org-special-ctrl-a/e t
  org-insert-heading-respect-content t

  ;; Org styling, hide markup etc
  org-hide-emphasis-markers t
  org-pretty-entities t
  org-ellipsis "..."

  ;; Agenda styling
  org-agenda-tags-column 0
  org-agenda-block-separator ?─
  org-agenda-time-grid
  '((daily today require-timed)
    (800 1000 1200 1400 1600 1800 2000)
    " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
  org-agenda-current-time-string
  "⭠ now ─────────────────────────────────────────────────"

  org-modern-block-name
  '(("src" . "")
    ("src" . "󰌠")
    ("result" . " result ")
    ("quote" . " quote")
    ("verse" . " verse")
    ("example" . "󰇥 example")
    ("comment" . " comment")
    ("center" . " center"))

  org-modern-keyword
  '(("results" . " Results")
    ("logbook" . " Logbook")
    ("clock" . " Clock")
    ("name" . " Name")
    ("title" . "󰗴")
    ("property" . "󱌣"))

  org-modern-star 'nil) ;; Use old org-modern star icons

(custom-set-faces!
  '(org-modern-label :height 1.1))

(global-org-modern-mode)
#+end_src

(It's pretty bare-bones for now, though the author has more examples for theming in their README.)

Use it globally and tweak it some more.

Org-modern comes with prettify-symbols mode, so I'm defining some symbols and
enabling it.

#+begin_src elisp
;; (setq prettify-symbols-alist
;;       '(("CLOCK:" . ?)
;;         (":LOGBOOK:" . ?)
;;         (":END:" . ?-)
;;         (":PROPERTIES:" . "p")))
#+end_src

*** Miscellanious improvements
**** Show passed deadlines as error

#+begin_src elisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

**** Show quote blocks in italic

#+begin_src elisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

**** Defer font-lock

For a more responsive editing experience

#+begin_src elisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))
#+end_src

*** TODO Hide ~:PROPERTY:~ Drawers
(Right now it's too dificult to get em back)

org-tidy is a package for hiding all ~:PROPERTY:~ drawers.

#+begin_src elisp :tangle packages.el
(package! org-tidy)
#+end_src

I want to enable it per default in org-mode, but be able to toggle it with
~<localleader>-z~

#+begin_src elisp
;; (use-package! org-tidy
;;   :defer t
;;   :hook (org-mode . org-tidy-mode)
;;   :config (map! :map org-mode-map
;;                 :localleader
;;                 :desc "Toggle org-tidy" "z" #'org-tidy-mode))
#+end_src

** Export

~ox-hugo~ allows exporting org files into Hugo-compatible markdown.

#+begin_src elisp :tangle packages.el
(package! ox-hugo)
#+end_src

#+begin_src elisp
(use-package! ox-hugo
  :after org
  :defer t
  :config
  (setq org-hugo-default-language "en"
        org-hugo-auto-export-mode t
        org-hugo-base-dir (concat org-directory "blog/")))
#+end_src

** Babel

Org-Babel provides two things related to code blocks:

1. a way to execute code blocks inside of org files. In a way, it's similar to Jupyter Notebooks,
though it supports a lot more languages on the one hand, but does not (easily) pass around context between cells on
the other.

1. "Tangling", meaning it will strip the prose surrounding the code blocks and generate a program from the individual code
      blocks in the document. In fact, that's how this config is generated.


*** HTTP requests via babel

ob-http is a package that allows for making HTTP requests from within org-mode
using babel.

#+begin_src elisp :tangle packages.el
(package! ob-http)
#+end_src

#+begin_src elisp
(use-package! ob-http
  :defer t
  :commands org-babel-execute:http)
#+end_src

Example usage:

#+begin_example
#+begin_src http :pretty
GET https://jsonplaceholder.typicode.com/posts/1
#+end_src

#+RESULTS:
: {
:   "userId": 1,
:   "id": 1,
:   "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
:   "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
: }
#+end_example

*** Babel header args

Sensible defaults for the various header arguments of code blocks.

See https://org-babel.readthedocs.io/en/latest/header-args/

#+begin_src elisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noeweb . "no")
        (:hlines . "no")
        ; (:tangle . "no")
        (:comments . "link")))
#+end_src

*** Auto-Tangling

I want org to tangle my config.org on file save, regardless whether it's the one
loaded or in a different repo.

#+begin_src elisp
(defun org-babel-tangle-config ()
  (when (string-equal (file-name-nondirectory (buffer-file-name))
                      "config.org")
    (let ((org-config-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'after-save-hook #'org-babel-tangle-config)))
#+end_src

*** Typescript

To execute typescript code blocks, I'm using the ~ob-typescript~ package.

#+begin_src elisp :tangle packages.el
(package! ob-typescript)
#+end_src

#+begin_src elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((typescript . t)))

(with-eval-after-load 'org
  (add-to-list 'org-src-lang-modes '("typescript" . typescript-ts))
  (add-to-list 'org-src-lang-modes '("ts" . typescript-ts)))
#+end_src

*** Export headings up to five levels deep

#+begin_src elisp
(setq org-export-headline-levels 5)
#+end_src

*** Latex fragments

#+begin_src elisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

*** Mermaid Diagrams

Using ob-mermaid, I can generate diagrams using the mermaid syntax.

#+begin_src elisp :tangle packages.el
(package! ob-mermaid)
#+end_src

Since mmdc is handled via nix, I'll need to get the binary's path during runtime via a shell call.

#+begin_src elisp
(setq ob-mermaid-cli-path (shell-command-to-string "printf %s \"$(readlink -f $(which mmdc))\""))
#+end_src

Then, I'll need to add mermaid to the list of babel languages.

#+begin_src elisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((mermaid . t)))
#+end_src

**** TODO All mermaid diagrams have a white background

** Roam

Org-Roam is a Zettelkasten implementation. In short, it allows for writing down multiple small notes and interlinking them,
creating pretty graphs. See also Obsidian or Logseq

*** Use the same directory as org

All roam files should be under a subdirectory of my org directory - so I can sync them with the same mechanism.

#+begin_src elisp
(setq org-roam-directory (concat org-directory "roam"))
#+end_src

*** TODO make good Capture Templates & Shortcuts

I'm adding some capture tempates for todos and journal entries, as well as some helper functions to directly call them.

I think they aren't working
#+begin_src elisp
(setq org-roam-capture-templates
      '(("d" "default" plain "%?" :target
         (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
         :unnarrowed t)

        ("j" "journal" plain "%?" :target  ; j for journal
         (file+head "journal/%<%Y-%m-%d>.org" "#+title: Journal %<%Y-%m-%d>\n")
         :unnarrowed t)

        ("p" "project" plain "%?" :target  ; p for project
         (file+head "projects/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: :project:\n")
         :unnarrowed t)

        ("m" "meeting" plain "%?" :target  ; m for meeting
         (file+head "meetings/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date: %<%Y-%m-%d>\n#+filetags: :meeting:\n")
         :unnarrowed t)

        ("i" "idea" plain "%?" :target     ; i for idea
         (file+head "ideas/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: :idea:\n")
         :unnarrowed t)

        ("t" "todo" plain "%?" :target     ; t for todo
        (file+head "todos/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: :todo:\n#+todo: TODO\n")
        :unnarrowed t)))
#+end_src


*** Add Org-Roam UI

Org-Roam UI is a web-based interface for Org-roam. It is a separate package -
and it also needs the websocket package as dependency.

The closest comparison to org-roam-ui is Obsidian.

#+begin_src elisp :tangle packages.el
(package! org-roam-ui)
(package! websocket)
#+end_src

#+begin_src elisp
(use-package! websocket
  :after org-roam
  :defer t)

(use-package! org-roam-ui
  :after org-roam
  :config
  (setq org-roam-ui-synch-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src


*** Automatic Blog Creation

Heavily inspired by https://www.asterhu.com/post/20240220-publish-org-roam-with-quartz-oxhugo/

#+begin_src elisp
;; (after! org
;;   (setq time-stamp-active t
;;         time-stamp-start "#\\+hugo_lastmod:[ \t]*"
;;         time-stamp-end "$"
;;         time-stamp-format "\[%Y-%m-%d\]")
;;   (add-hook 'before-save-hook 'time-stamp))
#+end_src

*** TODO Capture to Org Roam Dailies

I want to be able to use ~org-capture~ to capture stuff in the current date's roam daily file.

*** TODO Logseq compatibility

Org-Roam is so similar to Logseq that they can /almost/ be used together. I'm mostly following [[https://coredumped.dev/2021/05/26/taking-org-roam-everywhere-with-logseq/][Core Dumped's Guide on how to integrate both]]


**** Turn Logseq Nodes into Org-Roam Nodes

One of the incompatibilities between Logseq and Org-Roam is the way links between nodes are handled. Logseq inserts a file link, Org-Roam an Id link.
But nodes inserted via Logseq aren't properly recognized in Org-Roam.

There's an Elisp Snippet from Bill Burdick that turns Logseq notes into Org-Roam nodes (https://gist.github.com/zot/ddf1a89a567fea73bc3c8a209d48f527)

#+begin_src elisp
;; (load (expand-file-name "org-roam-logseq.el" doom-user-dir))
#+end_src

#+begin_src elisp :tangle packages.el
; (package! org-node)
#+end_src

#+begin_src elisp
; (use-package! org-node
;   :after org
;   :config (org-node-cache-mode))
#+end_src

Additionally, org-node-fakeroam can speed up org-roam itself, as well as allow for the usage of org-node and org-roam in parallel.

#+begin_src elisp :tangle packages.el
; (package! org-node-fakeroam)
#+end_src

#+begin_src elisp
; (use-package! org-node-fakeroam
  ; :defer)
#+end_src

** Combine Excalidraw Drawings with Orgmode Files

# #+begin_src elisp :tangle packages.el
# (package! org-excalidraw
#   :recipe (:host github :repo "wdavew/org-excalidraw"))
# #+end_src
#
# #+begin_src elisp :tangle
# (use-package! org-excalidraw
#   :after org
#   :config
#   (org-excalidraw-directory "~/org/excalidraw")
#   ;; Optionally set the default excalidraw binary or URL
#   (setq org-excalidraw-open "xdg-open")  ; Linux
#   )
# #+end_src

** Fixes and miscellanious improvements

*** Prevent org-block face for latex fragments, since they look weird

#+begin_src elisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

*** Nix-Doom-Emacs messes with dashboard

I'm using the nix-doom-emacs package to install emacs & dependencies, and for
some reason, using that binary, the Dashboard is disabled. [[https://github.com/nix-community/nix-doom-emacs/issues/88#issuecomment-1115500602][This comment]] in a
corresponding GH issue has a fix.

#+begin_src elisp
(add-hook! 'emacs-startup-hook #'doom-init-ui-h)
#+end_src

*** Faster insertion of org structures (i.e. source blocks)

Org-Tempo provides shortcuts like ~"<s" - <TAB>~ for generating code blocks.
For some reason, it does not start at launch, so I'm  loading it here.

#+begin_src elisp
(use-package! org-tempo)
#+end_src

*** Automatic list item insertion

The package ~org-autolist~ makes org lists behave more like traditional text
editors, meaning ~<Return>~ will insert a list item first, ~<Return><Return>~ will insert a
newline, etc.

#+begin_src elisp :tangle packages.el
(package! org-autolist)
#+end_src

#+begin_src elisp
(use-package! org-autolist
  :config
  (add-hook 'org-mode-hook #'org-autolist-mode))
#+end_src

*** Use org-cycle instead of +fold/toggle for TAB

~+fold/toggle~ breaks when trying to unfold, e.g. ~src~ blocks.

#+begin_src elisp
(after! org
  (map! :map org-mode-map
        :n [tab] #'org-cycle
        :i [tab] #'org-cycle
        :v [tab] #'org-cycle
        :m [tab] #'org-cycle))
#+end_src
** Capture

*** Add / change capture templates

Some other tools (like orgzly) work better with ~TODO~ instead of ~[ ]~, so I'm adjusting my capture templates.

#+begin_src elisp
(after! org
  (setq org-capture-templates
        '(("t" "Personal todo" entry (file+headline +org-capture-todo-file "Inbox")
          "* TODO %?\n%i\n%a" :prepend t)
         ("n" "Personal notes" entry (file+headline +org-capture-notes-file "Inbox")
          "* %u %?\n%i\n%a" :prepend t)
         ("j" "Journal" entry (file+olp+datetree +org-capture-journal-file)
          "* %U %?\n%i\n%a" :prepend t)
         ("p" "Templates for projects")
         ("pt" "Project-local todo" entry
          (file+headline +org-capture-project-todo-file "Inbox") "* TODO %?\n%i\n%a"
          :prepend t)
         ("pn" "Project-local notes" entry
          (file+headline +org-capture-project-notes-file "Inbox") "* %U %?\n%i\n%a"
          :prepend t)
         ("pc" "Project-local changelog" entry
          (file+headline +org-capture-project-changelog-file "Unreleased")
          "* %U %?\n%i\n%a" :prepend t)
         ("o" "Centralized templates for projects")
         ("ot" "Project todo" entry #'+org-capture-central-project-todo-file
          "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
         ("on" "Project notes" entry #'+org-capture-central-project-notes-file
          "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
         ("oc" "Project changelog" entry #'+org-capture-central-project-changelog-file
          "* %U %?\n %i\n %a" :heading "Changelog" :prepend t))))
#+end_src

*** TODO Improve org-capture dialog

#+BEGIN_SRC elisp
(after! org-capture
    (defun org-capture-select-template-prettier (&optional keys)
    "Select a capture template, in a prettier way than default
    Lisp programs can force the template by setting KEYS to a string."
    (let ((org-capture-templates
            (or (org-contextualize-keys
                (org-capture-upgrade-templates org-capture-templates)
                org-capture-templates-contexts)
                '(("t" "Task" entry (file+headline "" "Tasks")
                    "* TODO %?\n  %u\n  %a")))))
        (if keys
            (or (assoc keys org-capture-templates)
                (error "No capture template referred to by \"%s\" keys" keys))
        (org-mks org-capture-templates
                "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
                "Template key: "
                `(("q" ,(concat (nerd-icons-octicon "nf-oct-stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
    (advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier))
#+END_SRC

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but It would be even nicer with a smaller frame, and
no modeline.

#+BEGIN_SRC emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
      ;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+END_SRC

** Agenda and Time Management

*** Khal / Khalel
Khal is a  CLI tool for managing calendars and events. It can be synced with
various services, like Google Calendar, through vdirsyncer.

Khalel is an Emacs package that sits between the CLI and Org mode, allowing for
easy integration of Khal with Org.

#+begin_src elisp :tangle packages.el
(package! khalel)
#+end_src

#+begin_src elisp
(use-package! khalel
  :after org
  :config
  (khalel-add-capture-template))

(setq khalel-khal-command (shell-command-to-string "printf %s \"$(readlink -f $(which khal))\""))
(setq khalel-vdirsyncer-command "vdirsyncer")

(setq khalel-capture-key "e")
(setq khalel-import-org-file (concat org-directory "/" "calendar.org"))

(setq khalel-import-org-file-confirm-overwrite nil)

(setq khalel-import-end-date "+30d")

(khalel-add-capture-template)
#+end_src

** Querying & Combined Views

~org-ql~ provides a query language for org files. These queries can be used for searching & filtering org content, but also for generating new views.

#+begin_src elisp :tangle packages.el
(package! org-ql)
#+end_src

Additionally, ~org-roam-ql~ provides similar functionality for org-roam files.

#+begin_src elisp :tangle packages.el
(package! org-roam-ql)
#+end_src

#+begin_src elisp
(use-package! org-ql)
#+end_src

**** Org Similarity

Compares multiple org notes with each other and finds duplicates, based on a silimarity score.

#+begin_src elisp :tangle packages.el
;; (package! org-similarity)
#+end_src

#+begin_src elisp
;; (use-package org-similarity
;;   :load-path "org/similarity")
#+end_src

**** Unified Task Views

These views combine tasks from all your org files and roam notes, providing different perspectives on your work.

#+begin_src elisp
(defun my/org-ql-task-dashboard ()
  "Open a comprehensive task dashboard using org-ql."
  (interactive)
  (org-ql-search (org-agenda-files)
    '(and (todo "TODO" "NEXT" "DOING" "PROG" "WAIT")
          (not (todo "DONE" "CANCELLED" "CANCELED")))
    :title "Task Dashboard - Active Tasks Only"
    :sort '(deadline scheduled priority todo)
    :super-groups '((:name "Overdue"
                     :deadline past
                     :order 1)
                    (:name "Due Today"
                     :deadline today
                     :order 2)
                    (:name "Due This Week"
                     :deadline (between today +7)
                     :order 3)
                    (:name "Scheduled Today"
                     :scheduled today
                     :order 4)
                    (:name "High Priority"
                     :priority "A"
                     :order 5)
                    (:name "In Progress"
                     :todo ("DOING" "NEXT" "PROG")
                     :order 6)
                    (:name "Waiting"
                     :todo "WAIT"
                     :order 7)
                    (:name "Other TODOs"
                     :todo "TODO"
                     :order 8))))

(defun my/org-ql-stale-tasks ()
  "Find potentially stale tasks - active TODOs without recent activity."
  (interactive)
  (org-ql-search (org-agenda-files)
    '(and (todo "TODO" "NEXT" "DOING" "PROG" "WAIT")
          (not (todo "DONE" "CANCELLED" "CANCELED"))
          (not (ts :from -30)))
    :title "Potentially Stale Active Tasks (>30 days old)"
    :sort '(todo)
    :super-groups '((:name "Very Old (>90 days)"
                     :pred (lambda (item)
                             (when-let ((ts (org-element-property :raw-value 
                                            (org-element-property :timestamp 
                                             (org-element-at-point)))))
                               (time-less-p (date-to-time ts)
                                          (time-subtract (current-time) 
                                                       (days-to-time 90)))))
                     :order 1)
                    (:name "Old (30-90 days)"
                     :order 2))))

(defun my/org-ql-completed-tasks-review ()
  "Review completed tasks for potential cleanup."
  (interactive)
  (org-ql-search (org-agenda-files)
    '(todo "DONE" "CANCELLED" "CANCELED")
    :title "Completed Tasks Review"
    :sort '(todo)
    :super-groups '((:name "Done Tasks"
                     :todo "DONE"
                     :order 1)
                    (:name "Cancelled Tasks"
                     :todo ("CANCELLED" "CANCELED")
                     :order 2))))

(defun my/org-ql-week-review ()
  "Review tasks for the coming week."
  (interactive)
  (org-ql-search (org-agenda-files)
    '(and (todo "TODO" "NEXT" "DOING" "PROG" "WAIT")
          (not (todo "DONE" "CANCELLED" "CANCELED"))
          (or (deadline (between today +7))
              (scheduled (between today +7))
              (priority "A")))
    :title "Week Review - Focus Areas (Active Tasks Only)"
    :sort '(deadline scheduled priority)
    :super-groups '((:name "Critical This Week"
                     :and (:deadline (between today +7)
                           :priority "A")
                     :order 1)
                    (:name "Due This Week"
                     :deadline (between today +7)
                     :order 2)
                    (:name "Scheduled This Week"
                     :scheduled (between today +7)
                     :order 3)
                    (:name "High Priority (No Deadline)"
                     :priority "A"
                     :order 4))))
#+end_src

**** Context-Aware Task Queries

These functions help you understand where your tasks are clustering and provide project-specific views.

#+begin_src elisp
(defun my/org-ql-tasks-by-context ()
  "Group tasks by their containing file/context."
  (interactive)
  (org-ql-search (org-agenda-files)
    '(and (todo "TODO" "NEXT" "DOING" "PROG" "WAIT")
          (not (todo "DONE" "CANCELLED" "CANCELED")))
    :title "Active Tasks by Context"
    :sort '(todo)
    :super-groups '((:auto-parent t))))

(defun my/org-roam-ql-project-tasks ()
  "Find all tasks in org-roam notes tagged with projects."
  (interactive)
  (if (and (featurep 'org-roam) (bound-and-true-p org-roam-directory))
      (org-ql-search (list org-roam-directory)
        '(and (todo "TODO" "NEXT" "DOING" "PROG" "WAIT")
              (not (todo "DONE" "CANCELLED" "CANCELED"))
              (tags "project"))
        :title "Active Project Tasks (from Roam)")
    (message "org-roam not available or not configured")))

(defun my/org-ql-task-clusters ()
  "Find where tasks are clustering to identify overcommitment."
  (interactive)
  (org-ql-search (org-agenda-files)
    '(and (todo "TODO" "NEXT" "DOING" "PROG" "WAIT")
          (not (todo "DONE" "CANCELLED" "CANCELED"))
          (deadline (between today +14)))
    :title "Active Task Clustering Analysis (Next 2 Weeks)"
    :sort '(deadline scheduled)
    :super-groups '((:auto-outline-path t))))
#+end_src

**** Quick Task Operations

Streamlined functions for common task operations that work across your entire knowledge base.

#+begin_src elisp
(defun my/org-ql-toggle-task-done ()
  "Quick toggle task state in org-ql buffers."
  (interactive)
  (org-todo 'done))

(defun my/org-ql-reschedule-task ()
  "Reschedule task in org-ql buffer."
  (interactive)
  (org-schedule nil))

(defun my/org-ql-set-task-priority ()
  "Set task priority in org-ql buffer."
  (interactive)
  (org-priority))

;; Keybindings for org-ql buffers
(map! :map org-ql-view-map
      :n "t" #'my/org-ql-toggle-task-done
      :n "s" #'my/org-ql-reschedule-task
      :n "p" #'my/org-ql-set-task-priority
      :n "gr" #'org-ql-view-refresh)
#+end_src

**** Integration with Existing Workflow

Connect the new system with your existing capture templates and keybindings.

#+begin_src elisp
;; Add keybindings to your existing leader key setup
(map! :leader
      :desc "Task dashboard" "n q d" #'my/org-ql-task-dashboard
      :desc "Stale tasks" "n q s" #'my/org-ql-stale-tasks
      :desc "Week review" "n q w" #'my/org-ql-week-review
      :desc "Tasks by context" "n q c" #'my/org-ql-tasks-by-context
      :desc "Task clusters" "n q l" #'my/org-ql-task-clusters
      :desc "Project tasks" "n q p" #'my/org-roam-ql-project-tasks
      :desc "Review completed tasks" "n q r" #'my/org-ql-completed-tasks-review)

;; Replace default agenda with task dashboard
(map! :leader
      :desc "Task dashboard" "o A" #'my/org-ql-task-dashboard)
#+end_src

**** Performance Optimizations

Settings to ensure the query system remains responsive even with large numbers of files.

#+begin_src elisp
;; Optimize org-ql for large numbers of files
(setq org-ql-cache-persist t
      org-ql-cache-size 1000)

;; Only scan necessary directories for org-roam
(setq org-roam-file-extensions '("org")
      org-roam-scan-timeout 30)

;; Async refreshing to avoid blocking
(defun my/async-refresh-org-databases ()
  "Asynchronously refresh org databases."
  (run-with-timer 0.5 nil #'my/refresh-org-databases))

;; Hook into org-roam capture to refresh database
(add-hook 'org-roam-capture-new-node-hook #'my/async-refresh-org-databases)
#+end_src

* Workspaces & Projects
** Projectile Project Search Path

Search for projects in  ~~/Code/~, but only one level deep.

#+begin_src elisp
(setq projectile-project-search-path '(("~/Code/" . 1)))
#+end_src

** Disable Automatic Workspace Creation

Per default, emacs creates a workspace for every project - prohibiting, for
instance, side-by-side editing. I'm disabling this behavior.

#+begin_src elisp
(setq +workspaces-on-switch-project-behavior nil)
#+end_src

* Development
** Language-Specific Settings
*** Web Dev (JS/TS/CSS)
**** Testing

Add a package for Jest testing

#+begin_src elisp :tangle packages.el
(package! jest)
#+end_src

#+begin_src elisp
(use-package! jest
  :after (typescript-mode js-mode typescript-tsx-mode)
  :config
  (add-hook 'typescript-mode-hook #'jest-minor-mode))
#+end_src

Set up regexes for "sibling files" - so I'm able to jump from ~src/foo/bar.ts~ to ~test/foo/bar.test.ts.~

#+begin_src elisp
(setq find-sibling-rules
      '(("src/\\(.*/\\)?\\([^/]+\\)\\.\\(ts\\|vue\\)\\'"
         "test/.*\\2.test.ts")
        ("test/\\(.*/\\)?\\([^/]+\\)\\.test.ts\\'"
         "src/.*\\2.\\(ts\\|vue\\)")))
#+end_src

***** TODO This seems to only work for direct descendants of ~src~ and ~test~.

**** TODO Eslint

Eslint keeps track of all projects it has been run in, and - even if only one workspace is open,
will start to run in all of them.

The following sets it to run only in the current session.

#+begin_src elisp
;; (advice-add 'lsp
;;             :before (lambda (&rest _args)
;;                       (setf (lsp-session-server-id->folders (lsp-session)) (ht))))
#+end_src

Now, this runs into the issue that switching workspaces will not automatically
switch the client, so I'm adding a hook to restart all lsp clients when I'm
switching workspaces.

First, I need to define a function to restart all clients.

**** Svelte

#+begin_src elisp :tangle packages.el
(package! svelte-mode)
#+end_src

#+begin_src elisp
(use-package! svelte-mode
  :defer t
  :mode "\\.svelte\\'")
#+end_src

**** Vue
Vue SFC files are recognized and handled by ~web-mode~, so I only need to set up
some tweaks regarding the lsp and indentation.

⚠️ To get lsp support working, there needs to be a ~.volarrc~ file in the project's
root directory.

Remove 1 space padding from ~<script>~ tags, set indent to 2.

#+begin_src elisp
(with-eval-after-load 'web-mode
  (setq web-mode-script-padding 0)
  (setq web-mode-style-padding 0)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-markup-indent-offset 2))
#+end_src

**** Astro

Add a package for a dedicated ~astro~ mode:

#+begin_src elisp :tangle packages.el
(package! astro-ts-mode)
#+end_src

Because ~astro-ts-mode~ uses treesitter, treesitter needs to be set up to handle
~.astro~ files properly.

#+begin_src elisp
(setq treesit-language-source-alist
      '((astro "https://github.com/virchau13/tree-sitter-astro")
        (css "https://github.com/tree-sitter/tree-sitter-css")
        (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")))
#+end_src

Define Astro as a derived mode for ~.astro~ files.

#+begin_src elisp
(define-derived-mode astro-mode web-mode "astro")
(setq auto-mode-alist
      (append '(("\\.astro\\'" . astro-mode))
              auto-mode-alist))
#+end_src

Register the astro-ls binary for lsp support.

#+begin_src elisp
(with-eval-after-load 'lsp-mode
  (add-to-list 'lsp-language-id-configuration '(astro-mode . "astro"))
  (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection '("astro-ls"))
                    :activation-fn (lsp-activate-on "astro")
                    :server-id 'astro-ls)))
#+end_src

**** Tailwind

Add the tailwind lsp package

#+begin_src elisp :tangle packages.el
(package! lsp-tailwindcss
  :pin "3e3cc80a448e9dd24663eaa41742cda686dac5ab"
  :recipe (:host github
           :repo "merrickluo/lsp-tailwindcss"))
#+end_src

...and use it

#+begin_src elisp
(use-package! lsp-tailwindcss
  :defer t
  :init
  (setq lsp-tailwindcss-add-on-mode t)
  (setq lsp-tailwindcss-major-modes '(rjsx-mode web-mode html-mode css-mode typescript-mode typescript-tsx-mode rust-mode rustic-mode))
  )
#+end_src

**** Code formatting

Set typescript, javascript and json file indentation to be 2 levels by default.

#+begin_src elisp
(setq typescript-indent-level 2)
(setq js-indent-level 2)
#+end_src

**** TODO Typescript REPL
*** Nix

[[https://github.com/NixOS/nix-mode][Nix-mode]] is a major mode for editing nix expressions.

#+begin_src elisp
(use-package! nix-mode
  :mode "\\.nix\\'")
#+end_src

It comes with a variaty of
submodules:

**** nix.el

Nix.el contains some miscellanious tools. Interactive functions include:

- nix-unpack - unpack source of a Nix attribute.
  Available via ~M-x nix-unpack~ followed by the nix path and attribute path.

- nix-build - functions similar to ~M-x compile~. Will build in the current
  directory if it contains a ~default.nix~.

There are also basic functions for interacting with nix - some variables are
provided to point to Nix binaries that can be used in Lisp code.

- ~nix-executable~
- ~nix-build-executable~
- ~nixinstantiate-executable~
- ~nix-store-executable~
- ~nix-shell-executable~

Also, a function ~nix-system~ is provided to get the current system (the way Nix
detects it).

**** nix-flake.el

Uses transient.el to provide a magit-like interface for supporting flake
commands.
Using ~M-x nix-flake~ commands can be run on the current flake, whereas ~M-x
~nix-flake-init~ can initialize a flake from a atemplate.

**** nix-repls.el

Provides an interface for completion, nused by nix-company.el. Secondly it
provides an interactive function to open a repl via ~M-x nix-repl~

**** nix-store.el

Displays information about the store path including logs associated with a
derivation.

**** nix-prettify-mode.el

Improves display of store paths.

*** Python
**** Poetry

After years of frustration, I'm finally content with setting up and managing
projects in the Python ecosystem, thanks to Poetry. It's a great tool, and
luckily, there is excellent integration with Emacs.

#+begin_src elisp :tangle packages.el
(package! poetry)
#+end_src

**** Run pytest in virtualenv

python-pytest does not use the virtualenv's binary by default. As a fix, I'm
adding a hook to python-mode to set the correct executable - since python-mode
plays nicely with direnv.

#+begin_src elisp
(add-hook! python-mode
  (advice-add 'python-pytest-file :before
              (lambda (&rest args)
                (setq-local python-pytest-executable
                            (executable-find "pytest")))))
#+end_src

*** Terraform

There are two competing lsp servers for Terraform with support in Emacs, but,
although ~terraform-lsp~ is the more featurerich, I'm sticking with ~terraform-ls~
for now, but, ~terraform-lsp~ is a good alternative, with some nice- to- haves.

#+begin_src elisp
(setq lsp-terraform-ls-enable-show-reference t)
(setq lsp-semantic-tokens-enable t)
(setq lsp-semantic-tokens-honor-refresh-requests t)
#+end_src

*** Haskell

There's a Doom-Emacs module for setting up haskell-mode together with Haskell's
lsp, but currently, a bug prevents ~haskell-mode~ from working properly:
https://github.com/haskell/haskell-mode/issues/1825

A workaround is to explicitly set ~flymake-allowed-file-name-masks~ to nil.

#+begin_src elisp
(setq flymake-allowed-file-name-masks nil)
#+end_src

*** Jsonnet

Jsonnet is a data templating language.

First, a package for a jsonnet mode:

#+begin_src elisp :tangle packages.el
(package! jsonnet-mode)
#+end_src

Then, lsp support:

#+begin_src elisp
(defcustom lsp-jsonnet-executable "jsonnet-language-server"
  "The jsonnet executable to use for the jsonnet language server."
  :group 'lsp-jsonnet
  :risky t
  :type 'file)

(with-eval-after-load 'lsp-mode
  ;; Configure lsp-mode-language identifiers
  (add-to-list 'lsp-language-id-configuration '(jsonnet-mode . "jsonnet"))

  ;; Register jsonnet-language-server with the LSP client
  (lsp-register-client
    (make-lsp-client
      :new-connection (lsp-stdio-connection (lambda () lsp-jsonnet-executable))
      :activation-fn (lsp-activate-on "jsonnet")
      :initialized-fn (lambda (workspace)
                        (with-lsp-workspace workspace
                          (lsp--set-configuration
                            (lsp-configuration-section "jsonnet"))))
                    :server-id 'jsonnet-language-server))

  ;; Start language server when jsonnet-mode is enabled
  (add-hook 'jsonnet-mode-hook #'lsp-deferred))
#+end_src

*** Rust

Rust projects have multiple "features", for instance, in Leptos there are
backend and frontend features. Per default, I want all of them to be enabled for
the lsp:

#+begin_src elisp
(setq lsp-rust-features "all")
#+end_src

*** MDX

MDX is a format combining JSX and Markdown (More info: https://v0.mdxjs.com/).
Sadly, there is no real emacs support via major-mode or LSP, but I can approximate
something.

First, I'm setting the auto-mode for ~.mdx~ files to be ~markdown-mode~:

#+begin_src elisp
(setq auto-mode-alist
      (append '(("\\.mdx\\'" . markdown-mode))
              auto-mode-alist))
#+end_src
*** Gleam

Gleam is a strictly typed functional language that runs on the Erlang VM (and can also be transpiled to Javascript).

#+begin_src elisp :tangle packages.el
(package! gleam-ts-mode)
#+end_src

#+begin_src elisp
(use-package! gleam-ts-mode
  :config
  ;; setup formatter to be used by `SPC c f`
  (after! apheleia
    (setf (alist-get 'gleam-ts-mode apheleia-mode-alist) 'gleam)
    (setf (alist-get 'gleam apheleia-formatters) '("gleam" "format" "--stdin"))))

(after! treesit
  (add-to-list 'auto-mode-alist '("\\.gleam$" . gleam-ts-mode)))

(after! gleam-ts-mode
  (unless (treesit-language-available-p 'gleam)
    ;; compile the treesit grammar file the first time
    (gleam-ts-install-grammar)))
#+end_src

*** Lean
Lean is a proof-assistant language for formal mathematical verification.

Even though Doom Emacs has a "lean" module, that one has issues when Helm is missing. (And also isn't meant for lean 4).

Hence, I'm manually installing lean4-mode.

#+begin_src elisp :tangle packages.el
(package! lean4-mode
  :recipe (:host github
           :repo "leanprover-community/lean4-mode"
           :files ("*.el" "data")))
#+end_src

Additionally, I'm registering support for LSP

#+begin_src elisp
(with-eval-after-load 'lsp-mode
  (add-to-list 'lsp-language-id-configuration '(lean4-mode . "lean"))
  (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection '("lean --server"))
                    :activation-fn (lsp-activate-on "lean")
                    :server-id 'lean-ls)))
#+end_src

To execute lean code blocks, I'll need another package:

#+begin_src elisp :tangle packages.el
(package! ob-lean4
  :recipe (:host github
           :repo "Maverobot/ob-lean4"
           :files ("*.el")))
#+end_src

I'll need to set the path of the lean executable.

#+begin_src elisp
(use-package! ob-lean4
  :after org
  :config
  (add-to-list 'org-babel-load-languages '(lean4 . t)))
#+end_src

*** SageMath

**** Install and Package Set-Up

SageMath is a mathematics software system that integrates many existing open-source packages into a common interface for mathematical computation.
Through the ~ob-sagemath~ package, I can execute SageMath code blocks in org files.

#+begin_src elisp :tangle packages.el
(package! sage-shell-mode)
(package! ob-sagemath)
#+end_src

I'll use the default settings for now.

#+begin_src elisp
;; Ob-sagemath supports only evaluating with a session.
(setq org-babel-default-header-args:sage '((:session . t)
                                           (:results . "output")))

;; C-c c for asynchronous evaluating (only for SageMath code blocks).
(with-eval-after-load "org"
  (define-key org-mode-map (kbd "C-c c") 'ob-sagemath-execute-async))

;; Do not confirm before evaluation
(setq org-confirm-babel-evaluate nil)

;; Do not evaluate code blocks when exporting.
(setq org-export-babel-evaluate nil)

;; Show images when opening a file.
(setq org-startup-with-inline-images t)

;; Show images after evaluating code blocks.
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+end_src

**** TODO Some Org-Babel Settings

Additionally, I want to set up the parameters a bit, no default latex output for instance.

#+begin_src elisp
;; (setq org-babel-default-header-args:sage
;;       '((:session . "none")
;;         (:cache . "no")
;;         (:noeval . "no")
;;         (:hlines . "no")
;;         (:tangle . "no")
;;         (:comments . "link")))
#+end_src

** Tools
*** Code Completion

I recently migrated from company to corfu, as it's also integrated in Doom Emacs and much more lightweight.

**** Handling

I want to have a very low delay for the completion popup, and I want completions to start after the first letter.

#+begin_src elisp
(setq  corfu-auto-delay 0.1
       corfu-auto-prefix 2
       corfu-left-margin-width 2
       corfu-right-margin-width 2
       corfu-bar-width 1)
#+end_src

I don't want Corfu to show up in the minibuffer

#+begin_src elisp
(setq global-corfu-minibuffer nil)
#+end_src

**** UI

Since I rely on theme colors, I need to add a hook for when the theme changes so that everything stays in sync.

#+begin_src elisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")
(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))
#+end_src

Per default, the Corfu minibuffer is a bit cramped, so I'm adjusting its buffer parameters

#+begin_src elisp
(defun adjust-corfu-colors ()
  "Adjust corfu colors to match the current theme"
  (set-face-background 'corfu-border (doom-darken 'bg 0.25))
  (set-face-background 'corfu-current (doom-lighten 'bg 0.25)))

(eval-after-load 'corfu '(adjust-corfu-colors))

(setq corfu--frame-parameters '((internal-border-width . 5)
                                (min-width . 80)
                                (max-width . 100)))

(setq corfu--buffer-parameters '((mode-line-format . nil)
                                 (header-line-format . nil)
                                 (left-margin-width . 2)
                                 (right-margin-width . 2)
                                 (fringes-outside-margins . 0)))
#+end_src

Corfu has a popup info feature that shows documentation for the currently selected completion. The default delay values for this are way too high, so I'm setting them to 0.3 (initial) and 0.1 (subsequent) seconds.
I'm also tweaking some settings related to the hiding of the popup and its size.

#+begin_src elisp
(setq corfu-popupinfo-delay '(0.1 . 0.05)
      corfu-popupinfo-hide nil
      corfu-popupinfo-max-width 160
      corfu-popupinfo-min-width 160
      corfu-popupinfo-max-height 30
      corfu-popupinfo--buffer-parameters '((truncate-lines . nil)
                                           (left-margin-width . 2)
                                           (right-margin-width . 2)
                                           (word-wrap . t)))
#+end_src


*** Copilot

This package adds Github Copilot functionality to Emacs:

#+begin_src elisp :tangle packages.el
(package! copilot
  :recipe (:host github
           :repo "copilot-emacs/copilot.el"
           :files ("*.el" "dist")))
#+end_src

When enabling copilot, I'm hooking into ~prog-mode~ to enable it for all programming modes.
Further, I'm disabling the warning about indentation (see https://github.com/zerolfx/copilot.el/issues/220),
and binding some keys.

#+begin_src elisp
(use-package! copilot
  :defer t
  :config
  (add-hook 'prog-mode-hook #'copilot-mode)
  (add-hook 'copilot-mode-hook (lambda ()
                                  (setq-local copilot--indent-warning-printed-p t)))
  :bind (:map copilot-completion-map
              ("C-<space>" . 'copilot-accept-completion)
              ("C-SPC" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))
#+end_src

In insert mode, I'm binding  ~C-SPC~ to accept the complete suggestion. I'm also binding ~C-S-p~ and ~C-S-n~ to navigate through the suggestions.
Additionally, I'm binding ~i g s~ to show the suggestions, and ~i g c~
to insert the suggestion for use in normal mode, and ~t p~ to toggle Copilot.

#+begin_src elisp
(map! :leader
      :desc "Show Copilot Completion" "i g s" #'copilot-complete
      :desc "Insert Copilot Completion" "i g c" #'copilot-accept-completion
      :desc "Toggle Copilot" "t p" #'copilot-mode)
#+end_src


*** Debugging
Doom Emacs has a debugger module which uses ~dap-mode~ under the hood.

**** Language-Specific Debugger settings
***** Python

I'm using debugpy for python.

#+begin_src elisp
(setq dap-python-debugger 'debugpy)
#+end_src

**** Fixes
***** Fix Doom "+debugger/start"

By default, ~+debugger/start~ will look for the last configuration set in the
project's doom-store - which has to be cleared manually to reset. This function
will remove the debugger configuration from the doom-store.

#+begin_src elisp
;;;###autoload
(defun +debugger/clear ()
  "Clear the debugger configuration from the doom-store."
  (interactive)
  (doom-store-rem (doom-project-root) "+debugger"))
#+end_src

The old function is renamed to ~+debugger/repeat~.

#+begin_src elisp
(setq debugger-start-copy (symbol-function '+debugger/start))

;;;###autoload
(defun +debugger/repeat (arg)
  "Start the debugger."
  (interactive)
  (funcall debugger-start-copy arg))
#+end_src

And ~+debugger/start~  is redefined to clear the configuration before starting.

#+begin_src elisp
;;;###autoload
(defun +debugger/start (arg)
  "Launch a debugger session.
Launches the last used debugger, if one exists. Otherwise, you will be prompted
for what debugger to use. If the prefix ARG is set, prompt anyway."
  (interactive "P")
  (message arg)
  (+debugger--set-config (+debugger-completing-read))
  (+debugger/start-last))
#+end_src

***** Missing fringes in dap-mode
When running the dap-mode debugger, for some reason, the code window's fringes
get set to 0 width. This can be fixed with a workaround by setting the window's
buffer again via ~set-window-buffer~. Since this only should happen on windows
with file buffers, we need some helper functions to get the correct window.

****** Get the window containing a file buffer

Since there's only one window with a file buffer when running the debugger, this
can be kept fairly simple.

#+begin_src elisp
(defun get-window-with-file-buffer ()
  "Get the window with a file buffer."
  (seq-find (lambda (window)
              (buffer-file-name (window-buffer window)))
            (window-list)))
#+end_src

****** Reset file buffer window

Using the helper function, we can reset the file window's buffer.

#+begin_src elisp
(defun reset-file-window-buffer ()
  "Reset the file window's buffer."
  (let ((window (get-window-with-file-buffer)))
    (when window
      (set-window-buffer window (window-buffer window)))))

#+end_src

****** Add reset to window configuration change hook

Having tried multiple dap hooks to no avail, I've resigned to just resetting the
file window's buffer on every window configuration change. This can be achieved
with the ~window-configuration-change-hook~. Here, I only want to have the hook
active when in a dap session, so I'm adding the reset function after the dap
session has been created and removing it when the session is terminated.

#+begin_src elisp
(defun add-reset-file-window-buffer-hook (&rest args)
  "Add the reset-file-window-buffer function to the window-configuration-change-hook."
  (add-hook 'window-configuration-change-hook 'reset-file-window-buffer))

(defun remove-reset-file-window-buffer-hook (&rest args)
    "Remove the reset-file-window-buffer function from the window-configuration-change-hook."
    (remove-hook 'window-configuration-change-hook 'reset-file-window-buffer))

(add-hook 'dap-mode-hook 'add-reset-file-window-buffer-hook)
#+end_src

**** Keybindings
#+begin_src elisp
(map! :leader
      (:prefix-map ("d" . "debugger")
       :desc "Debug" "d" #'dap-debug
       :desc "Next" "n" #'dap-next
       :desc "Step in" "i" #'dap-step-in
       :desc "Step out" "o" #'dap-step-out
       :desc "Continue" "c" #'dap-continue
       :desc "Restart" "r" #'dap-restart-frame
       :desc "Disconnect" "D" #'dap-disconnect
       :desc "Evaluate" "e" #'dap-eval
       :desc "Add Expression" "a" #'dap-ui-expressions-add))
       ;; (:prefix ("b" . "breakpoints")
       ;;  :desc "Toggle" "t" #'dap-breakpoint-toggle
       ;;  :desc "Add" "a" #'dap-breakpoint-add
       ;;  :desc "Delete" "d" #'dap-breakpoint-delete
       ;;  :desc "Set condition" "c" #'dap-breakpoint-condition
       ;;  :desc "Set log message" "m" #'dap-breakpoint-log-message
       ;;  :desc "Set hit condition" "h" #'dap-breakpoint-hit-condition)))

#+end_src
*** Syntax Checking
For some reason, flycheck - especially when checking web files - is really slow.
To alleviate, it should only check the syntax on file-save.

#+begin_src elisp
(setq flycheck-syntax-automatically '(save-mode-enable))
#+end_src

*** LSP
For the LSP settings, I'm using the doom lsp module, which defaults to lsp-mode,
and lsp-ui. The alternative, eglot, would mean I'd have to set up the language
servers myself instead of relying on ~M-x lsp-install~. Although I have started to
work on a nix-workflow to install node-packages for that purpose, the
the ease of use of ~M-x lsp-install~ and the possibility of using lsp-ui means
I'll stick to lsp-mode for now.

Most of the language-specific settings are already defined under [[*Language-Specific Settings]].
Here, I'll define some general settings.

**** Performance
Using plists should increase the LSP performance.

#+begin_src elisp
(setq lsp-use-plists 't)
#+end_src

**** Handling
Set ~capf~ as completion provider.

#+begin_src elisp
(setq lsp-completion-provider :capf)
#+end_src

Don't show completion item detail

#+begin_src elisp
(setq lsp-completion-show-detail t)
#+end_src

Show completion item kind

#+begin_src elisp
(setq lsp-completion-show-kind t)
#+end_src

Automatically start LSP on file open, guess root.
#+begin_src elisp
(setq lsp-auto-guess-root t)
(add-hook 'prog-mode-hook #'lsp-deferred)
#+end_src

**** UI
Although I like using ~lsp-ui-doc~, I don't want it to appear every time I'm
hovering. Having a keybinding to glance at the documentation is fine for me.

#+begin_src elisp
(map! :leader
      :desc "Glance at documentation" "c g" #'lsp-ui-doc-glance)
#+end_src

Enable lenses
#+begin_src elisp
(setq lsp-lens-enable t)
#+end_src

Enable headerline with breadcrumbs.
#+begin_src elisp
(setq lsp-headerline-breadcrub-enable t)
#+end_src

Disable eldoc, as it does not look that good and mostly serves as a distraction.
#+begin_src elisp
(setq lsp-eldock-enable-hover nil)
#+end_src

Same with signature help, as well as help documentation
#+begin_src elisp
(setq lsp-signature-auto-activate nil)
(setq lsp-signature-render-documentation nil)
#+end_src

Set lsp-ui-doc sizing
#+begin_src elisp
(setq lsp-ui-doc-max-height 400
      lsp-ui-doc-max-width 250)
#+end_src

**** Emacs-LSP-Booster compatibility

LSP-Booster is a binary wrapper for language server binaries that pre-converts their JSON output to elisp bytecode
to offload this computation from emacs.

To correctly use it, I need to adjust the lsp command called from within emacs:

#+begin_src elisp
(defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))
(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
            (setcar orig-result command-from-exec-path))
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src

**** Git
Doom Emacs comes with Magit.

**** Disable Evil-Mode in timemachine mode
#+begin_src elisp
(eval-after-load 'git-timemachine
  '(progn
     (evil-make-overriding-map git-timemachine-mode-map 'normal)
     ;; force update evil keymaps after git-timemachine-mode loaded
     (add-hook 'git-timemachine-mode-hook #'evil-normalize-keymaps)))
#+end_src

**** Gitlab Integration
Although Doom comes with Forge, the intergration leaves some things to be
desired.
~lab.el~ is a package that provides more features that integrate with Gitlab,
like pipeline status, and MR interaction.

#+begin_src elisp :tangle packages.el
(package! lab)
#+end_src

Set up the package with the default instance and the token from my password manager.
#+begin_src elisp
(use-package! lab
  :config
  (setq lab-host "https://gitlab.com")
  (setq lab-token (password-store-get "bitwarden/gitlab-token")))
#+end_src

Add some keybindings und ~SPC g~ (Git)

#+begin_src elisp
(map! :leader
      :desc "List Pipelines" "g l p" #'lab-list-project-pipelines
      :desc "List Merge Requests" "g l m" #'lab-list-project-merge-requests
      :desc "List all owned projects" "g l o" #'lab-list-all-owned-projects)
#+end_src

**** Delta as Git Diff
#+begin_src elisp :tangle packages.el
(package! diff-ansi)
#+end_src

**** Devdocs
Devdocs (https://elpa.gnu.org/packages/devdocs.html) is a package for viewing
documentations, similar to Dash (https://kapeli.com/dash).

The documentation is hosted on https://devdocs.io/ and is open source. Sadly,
Devdocs can not read docsets from Dash.

***** Install

#+begin_src elisp :tangle packages.el
(package! devdocs)
#+end_src

***** Configuration
Add keybindings under ~SPC o D~ ("o" for "open", "D" for "Devdocs").

#+begin_src elisp
(map! :leader
      :desc "Open devdocs" "D o" #'devdocs-peruse
      :desc "Search devdocs" "D l" #'devdocs-lookup
      :desc "Install devdocs set" "D i" #'devdocs-install)
#+end_src

*** Aptel-api-keyI Assistance

**** AI In Emacs

**** TODO Ollama Buddy!
Ensures that we use the MELPA version.

Docs: https://www.dyerdwelling.family/emacs/20250207092636-emacs--ollama-buddy-local-llm-integration-for-emacs/

#+begin_src elisp :tangle packages.el
; (package! ollama-buddy)
#+end_src

#+begin_src elisp
; (use-package! ollama-buddy)
#+end_src


*** Task Runners

I'm switching from Makefiles to Justfiles, using ~just~.
There's ~just.el~ which allows you to call the recipe from within Emacs.

#+begin_src elisp :tangle packages.el
(package! justl :recipe (:host github :repo "psibi/justl.el"))
#+end_src

I want to bind ~just-exec-recipe~ to ~e~ in normal mode.

#+begin_src elisp
(use-package! justl
  :config

  (map! :leader
        :desc "Make" "c m" #'justl)
  (map! :n "e" 'justl-exec-recipe))
#+end_src

(I also want to have a major mode for editing Justfiles)

#+begin_src elisp :tangle packages.el
(package! just-mode)
#+end_src

*** Diagrams
**** Mermaid
~mermaid-mode~ is a package for live previewing mermaid diagrams.

#+begin_src elisp :tangle packages.el
(package! mermaid-mode)
#+end_src

I want to set a few default values for mermaid blocks so that they are prettier.

#+begin_src elisp
(setq org-babel-default-header-args:mermaid
      '((:background-color. "transparent")
        (:theme . "dark")
        (:results . "file")
        (:file . (lambda () (make-temp-file "mermaid" nil ".svg")))))
#+end_src

*** Markdown / Org Preview
There are multiple packages out there for previewing markdown, some of them not
maintained, some of them relying on the github API (via grip). Ideally, I'd like
to have a web browser open that auto reloads either based on me saving the file
or on a certain idle time.

~impatient-mode~ is a package for previewing HTML as you write it (including live-reload), so in theory,
using pandoc to convert the current buffer's content to HTML should make it
possible to preview anything that pandoc can convert.

Inspiration: https://blog.bitsandbobs.net/blog/emacs-markdown-live-preview/

First, I'll set up markdown-mode to use pandoc as ~markdown-command~.

#+begin_src elisp
(use-package markdown-mode
  :mode ("\\.md\\'" . gfm-mode)
  :commands (markdown-mode gfm-mode)
  :config
  (setq markdown-command "pandoc -f markdown -t html5"))
#+end_src

Now, ~impatient-mode~ as well as ~simple-httpd~.

#+begin_src elisp :tangle packages.el
(package! simple-httpd)
(package! impatient-mode)
#+end_src

#+begin_src elisp
(use-package simple-httpd
  :config
  (setq httpd-port 7070))

(use-package impatient-mode
  :commands impatient-mode)
#+end_src

Now, I'm defining a filter to process the markdown buffer.

TODO improve markdown filter

To make my life easier when defining the HTML, I'll use a library to convert
Lisp to XML/HTML

#+begin_src elisp :tangle packages.el
(package! esxml)
#+End_src

#+begin_src elisp
(defun markdown-html-filter (buffer)
  (princ
   (with-temp-buffer
     (let ((tmp (buffer-name)))
        (set-buffer buffer)
        (set-buffer (markdown tmp))
        (format "<!DOCTYPE html><html><title>Markdown Preview</title><link rel=\"stylesheet\" href = \"https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css\"/><body><article class=\"markdown-body\">%s</article></body></html>" (buffer-string))))
    (current-buffer)))
#+end_src

And finally, a function to start previewing the markdown buffer.

#+begin_src elisp
(defun markdown-html-preview ()
  "Preview Markdown in browser."
  (interactive)
  (unless (process-status "httpd")
    (httpd-start))
  (impatient-mode)
  (imp-set-user-filter 'markdown-html-filter)
  (imp-visit-buffer))

(defun markdown-html-preview-stop ()
  "Stop previewing Markdown in browser."
  (interactive)
  (imp-visit-buffer)
  (impatient-mode -1))

(map! :leader
      :desc "Preview" "m p" #'markdown-html-preview
      :desc "Stop Preview" "m s" #'markdown-html-preview-stop)
#+end_src

** Theming
*** Doom Themes

#+begin_src elisp :tangle packages.el
(package! doom-themes)
#+end_src

Doom Themes require ~all-the-icons~ to be installed (even though Doom itself moved on to nerd-icons).
To keep compatibility, I'm installing the package manually

#+begin_src elisp :tangle packages.el
(package! all-the-icons)
#+end_src

*** Catppuccin
Catppuccin is a color scheme using pastel colors. It's available for a variety
of tools.

#+begin_src elisp :tangle packages.el
(package! catppuccin-theme)
#+end_src

Catppuccin has different "flavors", which can be set via the ~catppuccin-flavor~
variable.

- ~latte~: Light theme
- ~frappe~: Dark theme, muted colors
- ~macciato~: Dark theme, semi-muted colors
- ~mocha~: (default) Dark theme, vibrant colors

Since the default is a bit too vibrant for my taste, I'm setting the flavor to ~frappe~.
#+begin_src elisp
(setq catppuccin-flavor 'frappe)
#+end_src

*** Current Theme

The theme I'm using for now is Doom-Nord-Aurora. It's included in ~doom-themes~, looks pretty similar to Doom Nord, but has a bit more muted colors.

#+begin_src elisp
(setq doom-theme 'doom-nord-aurora)
#+end_src

*** Misc Themes
**** Grayscale
#+begin_src elisp :tangle packages.el
(package! grayscale-theme)
#+end_src
It leetle much on the warm side for my tastes...

**** Tao Themes
Very appealing, minimalistic themes.

#+begin_src elisp :tangle packages.el
(package! tao-theme)
#+end_src

**** Ewal
Ewal (https://github.com/cyruseuros/ewal) is similar to (and builds upon)
pywal, but for Emacs. It allows you to set the theme of Emacs based on the
colors of your wallpaper. (Or other pictures).

#+begin_src elisp :tangle packages.el
(package! ewal)
(package! ewal-doom-themes)
#+end_src

#+begin_src elisp
(use-package ewal
  :init (setq ewal-use-built-in-always-p nil
              ewal-use-built-in-on-failure-p nil
              ewal-built-in-palette "sexy-material"))
#+end_src

*** Theme Magic
In a stark difference to the other solutions, which wants to adjust Emacs to the buty of the
rest of the world, Theme Magic (https://github.com/jcaw/theme-magic), which uses
PyWal (again!) to adjust every color it can to match your glorious editor.

#+begin_src elisp :tangle packages.el
(package! theme-magic)
#+end_src
*** Autothemer
More than auto"magically" generating hew themes, Autothemer
(https://github.com/jasonm23/autothemer) is more of a tool for those proficient
in themeing or those who want to be. a package for
generating color schemes, although it is more flexible than ewal or pywal.

#+begin_src elisp :tangle packages.el
(package! autothemer)
#+end_src

*** Base 16 Themes
Since they rely on only the 16 base terminal colors, base 16 themes are very
popular and make it easy to have a harmonized look across all your programs.
Fortunately, there is a base 16 theme for Doom Emacs, which stems from the
"Tinted Themeing project" (https://github.com/tinted-theming/home).

#+begin_src elisp :tangle packages.el
(package! base16-theme)
#+end_src

Some of the themes have a bit too less contrast for my taste. I think  the issue
is that all 16 colors are taken 'as-is', whereas it should be possible to
create a color scheme with more nuance via color correcting the applied colors.

~kurecolor~ seems to be a library aimed exactly at such a purpose.

#+begin_src elisp :tangle packages.el
(package! kurecolor)
#+end_src

**** TODO: Implement more complex color schemes based on base16 colors

** UI
*** Modelines
**** Doom Modeline

The iconic classic

Allow for more characters in the branch name

#+begin_src elisp
(setq doom-modeline-vcs-max-length 50)
#+end_src

#+begin_src elisp
(setq doom-modeline-hud t)
#+end_src

Disable additional unnecessary information

#+begin_src elisp
(after! doom-modeline
  (setq doom-modeline-buffer-encoding nil)
  (setq doom-modeline-modal nil)
  (setq doom-modeline-column-format "")
  (setq size-indication-mode nil)
  (setq doom-modeline-bar-width 0))
#+end_src

Remove size indicator and column number mode

#+begin_src elisp
(after! doom-modeline
  (remove-hook 'doom-modeline-mode-hook #'size-indication-mode) ; filesize in modeline
  (remove-hook 'doom-modeline-mode-hook #'column-number-mode)   ; cursor column in modeline
  (line-number-mode -1))
#+end_src

Hide Modeline in Treemacs

#+begin_src elisp
(add-hook 'treemacs-mode-hook (lambda () (hide-mode-line-mode)))
#+end_src

**** TODO Incorporate Nano Modeline

Rougier's minimalistic eyepiece from that brillian NANO design.

#+begin_src elisp :tangle packages.el
;; (package! nano-modeline)
#+end_src

#+begin_src elisp
;; (use-package! nano-modeline
;;   :config
;;   (nano-modeline-text-mode t))
#+end_src

*** General Padding

The way windows have been close together always kind of botheres me. Luckily,
there's a package that seems to halp with simple padding, without any
contortions.

#+begin_src elisp :tangle packages.el
(package! spacious-padding)
#+end_src

To actually use it, I need to find a better color scheme, where the edges aren't
as jarring, but it's very promising. The individual spacings can be adjusted
with the following:

#+begin_src elisp
(use-package! spacious-padding
  :config
  (setq spacious-padding-width '(
    :internal-border-width 20
    :header-line-width 8
    :mode-line-width 12
    :tab-width 16
    :right-divider-width 60
    :scroll-bar-width 12)))
#+end_src

Furthermore, there's a "subtle mode line setting", Which subdues the modelines a
bit. There's the possibility to target individual faces of the modelines and
change them based on whether they're active or not  - but I'm content with just
setting the modeline to have the window's background color.

#+begin_src elisp
(setq spacious-padding-subtle-mode-line t)
#+end_src

Now that everything's set up, I'm enabling the mode.

#+begin_src elisp
(spacious-padding-mode 1)
#+end_src

(The actual values obviously need to be tweaked though)

*** Better Error Display

The posframe that flycheck-posframe is using for error display seems to linger
for a while, and does not disappear until you stop moving the cursor.

This snippet makes it disappear instantly:

#+begin_src elisp
(when (featurep! :checkers syntax +childframe)
  (defun flycheck-posframe-monitor-post-command ()
    (when (not (flycheck-posframe-check-position))
      (posframe-hide flycheck-posframe-buffer)))

  (defun fix-flycheck-posframe-not-hide-immediately ()
    (cond (flycheck-posframe-mode
           (add-hook 'post-command-hook 'flycheck-posframe-monitor-post-command nil t))
          ((not flycheck-posframe-mode)
           (remove-hook 'post-command-hook 'flycheck-posframe-monitor-post-command t))))
  (add-hook! flycheck-posframe-mode #'fix-flycheck-posframe-not-hide-immediately))
#+end_src

*** Treemacs Modeline

I don't really need the modeline in the treemacs buffer, so I'm disabling it.

#+begin_src elisp
(add-hook 'treemacs-mode-hook #'hide-mode-line-mode)
#+end_src

*** Solaire-Mode
Solaire-Mode provides a way to change the background color of buffers that are
not the current buffer, making the current buffer stand out more.

This is enabled per default in Doom Emacs, but it results in issues with Treemacs,
so I'm disabling it.

#+begin_src elisp :tangle packages.el
(package! solaire-mode :disable t)
#+end_src

** Vertico

Prefix the current candidate with an arrow
#+begin_src elisp
(defun minibuffer-format-candidate (orig cand prefix suffix index _start)
  (let ((prefix (if (= vertico--index index)
                    " > " "   ")))
    (funcall orig cand prefix suffix index _start)))

(advice-add #'vertico--format-candidate
            :around #'minibuffer-format-candidate)
#+end_src

Don't show results count
#+begin_src elisp
(setq vertico-count-format nil)
#+end_src

Make vertico-posframe a little wider
#+begin_src elisp
(setq vertico-posframe-width 200)
#+end_src

Add fringe to vertico-posframea
#+begin_src elisp
(setq vertico-posframe-parameters
      '((left-fringe . 16)
        (right-fringe . 8)
        (border-width . 16)))
#+end_src

** Kubernetes
~kubernetes-mode~ brings a lot of snippets.

#+begin_src elisp :tangle packages.el
(package! k8s-mode)
(package! k8s-mode)
#+end_src

* Performance
Various tweaks to improve the overall performance.

Raise the GC-Cons threshold
#+begin_example elisp
(setq gc-cons-threshold (* 1024 1024 1024)) ;; 1G
#+end_example

Increase the amount of data which Emacs reads from the process
#+begin_src elisp
(setq read-process-output-max (* 4 1024 1024)) ;; 4mb
#+end_src

Ignore JSONRPC logs
#+begin_src elisp
(fset #'jsonrpc--log-event #'ignore)
#+end_src

* AI

Through gptel and a thriving ecosystem, Emacs has become extremely powerful when dealing with AI.

** GPTel Configuration

GPTel (https://github.com/karthink/gptel) is a module for interacting with various LLMs.

As it is enabled via a Doom module, I only need to make adjustments after the module itself has loaded, hence all these code blocks are wrapped in an ~after! gptel~ block.

*** AI Model Backends

I'm using the IU Unified Endpoint as a default. It behaves just like the openai one, which is why I have to take care to keep the settings aligned.

Setting up Kagi is more or less straightforward.
#+begin_src elisp
(after! gptel
  (gptel-make-kagi "Kagi" :key (password-store-get "bitwarden/kagi_token")))
#+end_src

** Additional Settings

I want the GPTel chat to be an org-mode document per default.

#+begin_src elisp
(after! gptel
  (setq gptel-default-mode 'org-mode)
  (setq gptel-org-branching-context t)
  (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "@user\n")
  (setf (alist-get 'org-mode gptel-response-prefix-alist) "@assistant\n"))
#+end_src


** Extensions
*** Babel evaluation via ob-gptel

#+begin_src elisp :tangle packages.el
(package! ob-gptel
  :recipe (:host github
           :repo "jwiegley/ob-gptel"
           :files ("*.el")))
#+end_src

#+begin_src elisp
(use-package! ob-gptel
  :hook ((org-mode . ob-gptel-install-completions))
  :defines ob-gptel-install-completions
  :config
  (add-to-list 'org-babel-load-languages '(gptel . t))
  (defun ob-gptel-install-completions ()
    (add-hook 'completion-at-point-functions
              'ob-gptel-capf nil t)))
#+end_src

*** MCP

#+begin_src elisp :tangle packages.el
(package! mcp)
#+END_SRC

#+begin_src elisp
(add-to-list 'exec-path "/usr/local/bin")
(setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
#+end_src

#+begin_src elisp
(setq mcp-hub-servers
      '(("fetch" . (:command "uvx" :args ("mcp-server-fetch")))
        ("browser" . (:command "npx" :args ("-y" "@browsermcp/mcp@latest")))
        ("atlassian" . (:command "docker"
                        :args ("run"
                               "--rm"
                               "-i"
                               "--env-file"
                               "/tmp/atlassian"
                               "ghcr.io/sooperset/mcp-atlassian:latest")))))
(use-package! mcp)
#+end_src

#+begin_src elisp :tangle packages.el
(package! gptel-mcp
    :recipe (:host github
             :repo "lizqwerscott/gptel-mcp"))
#+end_src

#+begin_src elisp
(use-package! gptel-mcp
  :bind (:map gptel-mode-map
              ("C-c m" . gptel-mcp-dispatch)))
#+end_src

* Unsorted Packages
** pcre2el

pcre2el is included with doom emacs but pinned to a version that is currently throwing warnings because of an
obsolete variable.

#+begin_src elisp :tangle packages.el
(unpin! pcre2el)
#+end_src

** Discord Presence
#+begin_src elisp :tangle packages.el
(package! elcord)
#+end_src

#+begin_src elisp
(use-package! elcord
  :config
  (setq elcord-editor-icon "emacs_icon"))
#+end_src
